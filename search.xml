<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Goland实现优先队列</title>
      <link href="/post/ab438f79.html"/>
      <url>/post/ab438f79.html</url>
      
        <content type="html"><![CDATA[<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><ol><li>常规实现方法 - 大根堆<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeight</span><span class="params">(stones []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">hp := &amp;Heap&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> stones &#123;</span><br><span class="line">heap.Push(hp, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> hp.Len() &gt; <span class="number">1</span> &#123;</span><br><span class="line">x, y := heap.Pop(hp).(<span class="type">int</span>), heap.Pop(hp).(<span class="type">int</span>)</span><br><span class="line"><span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">x, y = y, x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> x == y &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">heap.Push(hp, y-x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hp.Len() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hp.Top()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Heap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Heap)</span></span> Len() <span class="type">int</span>            &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Heap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span>  &#123; <span class="keyword">return</span> h[i] &gt; h[j] &#125; <span class="comment">// 大根</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Heap)</span></span> Swap(i, j <span class="type">int</span>)       &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Heap)</span></span> Top() <span class="type">int</span>            &#123; <span class="keyword">return</span> h[<span class="number">0</span>] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123; *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Heap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(*h)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[:n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>使用sort.IntSlice快速实现<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeight</span><span class="params">(stones []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">q := &amp;hp&#123;stones&#125;</span><br><span class="line">heap.Init(q)</span><br><span class="line"><span class="keyword">for</span> q.Len() &gt; <span class="number">1</span> &#123;</span><br><span class="line">x, y := q.pop(), q.pop()</span><br><span class="line"><span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">q.push(x - y)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> q.Len() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> q.top()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> hp <span class="keyword">struct</span> &#123;</span><br><span class="line">sort.IntSlice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h.IntSlice[i] &gt; h.IntSlice[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123; h.IntSlice = <span class="built_in">append</span>(h.IntSlice, x.(<span class="type">int</span>)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">old := h.IntSlice</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">h.IntSlice = old[:n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> pop() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> heap.Pop(h).(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> push(x <span class="type">int</span>) &#123;</span><br><span class="line">heap.Push(h, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hp)</span></span> top() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h.IntSlice[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Goland </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣刷题记录</title>
      <link href="/post/8ae993b6.html"/>
      <url>/post/8ae993b6.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>2023.11.23</p></blockquote><ol><li><a href="https://leetcode.cn/problems/integer-break">整数拆分</a></li><li><a href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a></li><li><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></li><li><a href="https://leetcode.cn/problems/last-stone-weight">最后一块石头的重量</a></li><li><a href="https://leetcode.cn/problems/last-stone-weight-ii/">最后一块石头的重量 II</a></li><li><a href="https://leetcode.cn/problems/target-sum/">目标和</a><!-- 1. []( ) --></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go1.21新增slices包的使用....</title>
      <link href="/post/dcfa5bf0.html"/>
      <url>/post/dcfa5bf0.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="1-slices-Max-slices-Min"><a href="#1-slices-Max-slices-Min" class="headerlink" title="1. slices.Max slices.Min"></a>1. slices.Max slices.Min</h2><p>源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Max returns the maximal value in x. It panics if x is empty.</span></span><br><span class="line"><span class="comment">// For floating-point E, Max propagates NaNs (any NaN value in x</span></span><br><span class="line"><span class="comment">// forces the output to be NaN).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span>[<span class="title">S</span> ~[]<span class="title">E</span>, <span class="title">E</span> <span class="title">cmp</span>.<span class="title">Ordered</span>]<span class="params">(x S)</span></span> E &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(x) &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;slices.Max: empty list&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">m := x[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line">m = max(m, x[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Min returns the minimal value in x. It panics if x is empty.</span></span><br><span class="line"><span class="comment">// For floating-point numbers, Min propagates NaNs (any NaN value in x</span></span><br><span class="line"><span class="comment">// forces the output to be NaN).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Min</span>[<span class="title">S</span> ~[]<span class="title">E</span>, <span class="title">E</span> <span class="title">cmp</span>.<span class="title">Ordered</span>]<span class="params">(x S)</span></span> E &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(x) &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;slices.Min: empty list&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">m := x[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(x); i++ &#123;</span><br><span class="line">m = min(m, x[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回x的最大值，如果x为空，则panic。对于浮点数类型，如果NaN存在于Slice中，则返回Slice</span></span><br></pre></td></tr></table></figure><p>如何使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f := []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>&#125;</span><br><span class="line">f1 := []<span class="type">float64</span>&#123;<span class="number">1.1</span>, <span class="number">1.2</span>, math.NaN()&#125;</span><br><span class="line">fmt.Println(slices.Max(f), slices.Min(f))</span><br><span class="line">fmt.Println(slices.Max(f1), slices.Min(f1))</span><br></pre></td></tr></table></figure><h2 id="2-slices-MaxFunc、slices-MinFunc"><a href="#2-slices-MaxFunc、slices-MinFunc" class="headerlink" title="2. slices.MaxFunc、slices.MinFunc"></a>2. slices.MaxFunc、slices.MinFunc</h2><p>针对结构体取按照某个字段排序取最大、最小值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">users := []User&#123;&#123;name: <span class="string">&quot;LXJ&quot;</span>, salary: <span class="number">10</span>&#125;, &#123;name: <span class="string">&quot;ZN&quot;</span>, salary: <span class="number">20</span>&#125;, &#123;name: <span class="string">&quot;HH&quot;</span>, salary: <span class="number">30</span>&#125;&#125;</span><br><span class="line">user := slices.MaxFunc(users, <span class="function"><span class="keyword">func</span><span class="params">(a, b User)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cmp.Compare(a.salary, b.salary)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(user.name)</span><br></pre></td></tr></table></figure><h2 id="3-slices-Reverse"><a href="#3-slices-Reverse" class="headerlink" title="3. slices.Reverse"></a>3. slices.Reverse</h2><p>反转切片中的元素。</p><h2 id="4-slices-Sort"><a href="#4-slices-Sort" class="headerlink" title="4. slices.Sort"></a>4. slices.Sort</h2><p>对有序类型的切片进行升序排序。对于浮点数类型，NaN 排在其它值之前。</p><h2 id="5-slices-SortFunc"><a href="#5-slices-SortFunc" class="headerlink" title="5. slices.SortFunc"></a>5. slices.SortFunc</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据salary从小到大排序</span></span><br><span class="line">slices.SortFunc(users, <span class="function"><span class="keyword">func</span><span class="params">(a, b User)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cmp.Compare(a.salary, b.salary)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 根据salary从大到小排序</span></span><br><span class="line">slices.SortFunc(users, <span class="function"><span class="keyword">func</span><span class="params">(a, b User)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cmp.Compare(b.salary, a.salary)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="6-slices-SortStableFunc"><a href="#6-slices-SortStableFunc" class="headerlink" title="6. slices.SortStableFunc"></a>6. slices.SortStableFunc</h2><p>稳定排序</p><h2 id="7-slices-BinarySearch"><a href="#7-slices-BinarySearch" class="headerlink" title="7. slices.BinarySearch"></a>7. slices.BinarySearch</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找第一个大于等于target的下标  [f[index] &gt;= target]</span></span><br><span class="line"><span class="comment">// 找到的该数若等于target则返回true 否则返回false。无论最终找没找到都返回下标</span></span><br><span class="line">index, ok := slices.BinarySearch(f, target);</span><br></pre></td></tr></table></figure><h2 id="8-slices-BinarySearchFunc"><a href="#8-slices-BinarySearchFunc" class="headerlink" title="8. slices.BinarySearchFunc"></a>8. slices.BinarySearchFunc</h2><p>针对结构体的某个字段…</p><h2 id="9-slices-Clip"><a href="#9-slices-Clip" class="headerlink" title="9. slices.Clip"></a>9. slices.Clip</h2><p>从切片中删除未使用的容量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(name), <span class="built_in">cap</span>(name)) <span class="comment">// 2 5</span></span><br><span class="line">name = slices.Clip(name)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(name), <span class="built_in">cap</span>(name)) <span class="comment">// 2 2</span></span><br></pre></td></tr></table></figure><h2 id="10-slices-Clone"><a href="#10-slices-Clone" class="headerlink" title="10.slices.Clone"></a>10.slices.Clone</h2><p>属于是深拷贝了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">nameCopy := slices.Clone(name)</span><br><span class="line">fmt.Println(name, nameCopy) <span class="comment">// [1 2 3 4 5] [1 2 3 4 5]</span></span><br><span class="line">nameCopy[<span class="number">0</span>] = <span class="number">10000</span></span><br><span class="line">fmt.Println(name, nameCopy) <span class="comment">// [1 2 3 4 5] [10000 2 3 4 5]</span></span><br></pre></td></tr></table></figure><h2 id="11-slices-Compact"><a href="#11-slices-Compact" class="headerlink" title="11.slices.Compact"></a>11.slices.Compact</h2><p>将连续出现的元素变为一个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>&#125;</span><br><span class="line">name = slices.Compact(name)</span><br><span class="line">fmt.Println(name) <span class="comment">// [1 2 3 4 5 1 0 1 2]</span></span><br></pre></td></tr></table></figure><h2 id="12-slices-CompactFunc"><a href="#12-slices-CompactFunc" class="headerlink" title="12.slices.CompactFunc"></a>12.slices.CompactFunc</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names := []<span class="type">string</span>&#123;<span class="string">&quot;bob&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;Vera&quot;</span>, <span class="string">&quot;VERA&quot;</span>&#125;</span><br><span class="line">names = slices.CompactFunc(names, <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.ToLower(a) == strings.ToLower(b)</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(names) <span class="comment">// [bob alice Vera]</span></span><br></pre></td></tr></table></figure><h2 id="12-slices-Equal"><a href="#12-slices-Equal" class="headerlink" title="12. slices.Equal"></a>12. slices.Equal</h2><p>判断两个切片是否相等（长度相同且所有元素相等）。如果长度不同，返回 false。如果长度相同，将按索引递增的顺序比较元素，并在第一个不相等出现时停止比较。</p><h2 id="13-slices-Insert"><a href="#13-slices-Insert" class="headerlink" title="13.slices.Insert"></a>13.slices.Insert</h2><p>在某个位置插入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   names := []<span class="type">string</span>&#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Vera&quot;</span>&#125;</span><br><span class="line">names = slices.Insert(names, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">fmt.Println(names)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Goland </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx使用</title>
      <link href="/post/77baee2a.html"/>
      <url>/post/77baee2a.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-安装好Docker"><a href="#1-安装好Docker" class="headerlink" title="1. 安装好Docker"></a>1. 安装好Docker</h3><h3 id="2-拉取Nginx镜像"><a href="#2-拉取Nginx镜像" class="headerlink" title="2. 拉取Nginx镜像"></a>2. 拉取Nginx镜像</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><h3 id="3-启动Nginx"><a href="#3-启动Nginx" class="headerlink" title="3. 启动Nginx"></a>3. 启动Nginx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name [container_name] -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><h3 id="4-验证、访问Nginx"><a href="#4-验证、访问Nginx" class="headerlink" title="4. 验证、访问Nginx"></a>4. 验证、访问Nginx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps # 查看是否正常运行</span><br></pre></td></tr></table></figure><p>网页访问，浏览器输入IP地址回车，就可以看到 “Welcome to nginx!”</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="1-在本地创建管理目录"><a href="#1-在本地创建管理目录" class="headerlink" title="1. 在本地创建管理目录"></a>1. 在本地创建管理目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/nginx/conf</span><br><span class="line">mkdir -p /home/nginx/log</span><br><span class="line">mkdir -p /home/nginx/html</span><br></pre></td></tr></table></figure><h3 id="2-将容器中的相应文件copy到刚创建的管理目录中"><a href="#2-将容器中的相应文件copy到刚创建的管理目录中" class="headerlink" title="2. 将容器中的相应文件copy到刚创建的管理目录中"></a>2. 将容器中的相应文件copy到刚创建的管理目录中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp nginx:/etc/nginx/nginx.conf /home/nginx/conf/nginx.conf</span><br><span class="line">docker cp nginx:/etc/nginx/conf.d /home/nginx/conf/conf.d</span><br><span class="line">docker cp nginx:/usr/share/nginx/html /home/nginx/</span><br></pre></td></tr></table></figure><h3 id="3-停止并移除容器"><a href="#3-停止并移除容器" class="headerlink" title="3. 停止并移除容器"></a>3. 停止并移除容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 需要先停止、再删除</span><br><span class="line">docker stop nginx</span><br><span class="line">docker rm nginx</span><br></pre></td></tr></table></figure><h3 id="4-再次启动容器并作目录挂载"><a href="#4-再次启动容器并作目录挂载" class="headerlink" title="4. 再次启动容器并作目录挂载"></a>4. 再次启动容器并作目录挂载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 授予容器所有权限，以便它可以访问和修改宿主机的文件系统。</span><br><span class="line">docker run -p 80:80 --name nginx -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /home/nginx/conf/conf.d:/etc/nginx/conf.d -v /home/nginx/log:/var/log/nginx -v /home/nginx/html:/usr/share/nginx/html -d nginx:latest</span><br></pre></td></tr></table></figure><p>到此部署就完成啦！</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令整理...</title>
      <link href="/post/e6344dc0.html"/>
      <url>/post/e6344dc0.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-用户创建"><a href="#1-用户创建" class="headerlink" title="1. 用户创建"></a>1. 用户创建</h2><p>   到手一台服务器，直接使用root用户进行各种操作，具有较大风险，特别是对于小白来讲。所以，需要创建一个工作用户，用于日常工作、学习使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adduser Jannan # 创建用户Jannan（名字随意取</span><br><span class="line">usermod -aG sudo Jannan # 给用户Jannan分配sudo权限（将用户加入sudo用户组 a-追加[append]</span><br></pre></td></tr></table></figure><h2 id="2-docker相关"><a href="#2-docker相关" class="headerlink" title="2. docker相关"></a>2. docker相关</h2><p>为了避免每次使用<code>docker</code>命令都需要加上<code>sudo</code>权限，可以将当前用户加入安装中自动创建的<code>docker</code>用户组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><h3 id="images"><a href="#images" class="headerlink" title="images"></a>images</h3><ol><li>列出本地所有镜像：<code>docker images</code></li><li>拉取一个镜像：<code>docker pull ubuntu:20.04  #:20.04指定版本，不写默认最新版</code></li><li>删除镜像：<code>docker image rm ubuntu:20.04</code></li><li><code>docker [container] commit CONTAINER IMAGE_NAME:TAG</code>：创建某个<code>container</code>的镜像</li><li><code>docker save -o ubuntu_20_04.tar ubuntu:20.04</code>：将镜像<code>ubuntu:20.04</code>导出到本地文件<code>ubuntu_20_04.tar</code>中</li><li><code>docker save -o ubuntu_20_04.tar ubuntu:20.04</code>：将镜像<code>ubuntu:20.04</code>导出到本地文件<code>ubuntu_20_04.tar</code>中</li></ol><h3 id="containers"><a href="#containers" class="headerlink" title="containers"></a>containers</h3><ol><li><code>docker ps -a</code>：查看本地的所有容器</li><li><code>docker start CONTAINER</code>：启动容器</li><li><code>docker stop CONTAINER</code>：停止容器</li><li><code>docker restart CONTAINER</code>：重启容器</li><li><code>docker attach CONTAINER</code>：进入容器<ul><li>先按<code>Ctrl-p</code>，再按<code>Ctrl-q</code>可以挂起容器</li></ul></li><li><code>docker exec CONTAINER COMMAND</code>：在容器中执行命令</li><li><code>docker rm CONTAINER</code>：删除容器</li><li><code>docker container prune</code>：删除所有已停止的容器</li></ol><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><ol><li><code>docker logs [容器名 | 容器ID ]</code></li><li><code>docker logs -f  [容器名 | 容器ID ]</code> # 表示实时的跟踪日志输出</li><li><code>docker logs --since 30m myredis</code> # 此处 –since 30m 是查看此容器30分钟之内的日志情况。</li></ol><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>创建一个Dockerfile</li><li>使用Dockerfile构建镜像</li><li>使用镜像创建和运行容器</li></ol><h4 id="实践部分"><a href="#实践部分" class="headerlink" title="实践部分"></a>实践部分</h4><ul><li><a href="https://www.docker.com/play-with-docker/">在线Docker环境</a></li></ul><p>文件目录结构：</p><ul><li>HelloDocker<ul><li>Dockerfile</li><li>index.js</li></ul></li></ul><p>index.js编写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello Docker!&#x27;</span>);</span><br></pre></td></tr></table></figure><p>Dockerfile编写</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alpine 精简版的操作系统</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">14</span>-alpine </span><br><span class="line"><span class="comment"># source dest</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> index.js /index.js</span></span><br><span class="line"><span class="comment"># cmd </span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> node /index.js</span></span><br></pre></td></tr></table></figure><p>构建完文件目录之后，执行<code>docker build -t hello-docker .</code>，之后<code>docker run hello-docker</code>即可运行<code>docker</code>容器。</p><p>如果想在另一个环境运行这个应用程序，只需要把镜像文件复制过去，再执行<code>docker run hello-docker</code>即可运行。也可以把镜像文件上传到<code>Docker Hub</code>上，结合<code>docker pull</code>可以快速运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># geekhour为用户名，hello-docker为镜像名</span><br><span class="line">docker pull geekhour/hello-docker</span><br></pre></td></tr></table></figure><h4 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h4><p><code>docker run --restart=always -p 6379:6379 --name redis_study -d redis --requirepass root</code></p><ul><li>–restart&#x3D;always 参数表示在容器崩溃时，Docker 会自动重启该容器</li><li>-p 6379:6379 参数表示将容器的 6379 端口映射到宿主机的 6379 端口</li><li>–name myredis 参数为容器指定一个名称，便于识别</li><li>-d 参数表示以分离模式运行容器</li><li>–requirepass root 参数表示设置 Redis 密码。</li></ul><p><code>docker exec -it [容器名 | 容器ID] bash</code> # 以交互的方式进入容器内部</p><h4 id="容器打包上传Docker-Hub"><a href="#容器打包上传Docker-Hub" class="headerlink" title="容器打包上传Docker Hub"></a>容器打包上传Docker Hub</h4><ol><li><code>docker login</code></li><li><code>docker commit my_docker my_docker:v1</code></li><li><code>docker tag my_docker:v1 jannanxj/my_docker:v1</code></li><li><code>docker push jannanxj/my_docker:v1</code></li></ol><h2 id="3-简单命令"><a href="#3-简单命令" class="headerlink" title="3. 简单命令"></a>3. 简单命令</h2><h3 id="常用的文件、目录命令"><a href="#常用的文件、目录命令" class="headerlink" title="常用的文件、目录命令"></a>常用的文件、目录命令</h3><ol><li><code>ls</code>：用户查看目录下的文件，<code>ls -a</code>可以用来查看隐藏文件，<code>ls -l</code>可以用于查看文件的详细信息，包括权限、大小、所有者等信息</li><li><code>touch</code>：用于创建文件。如果文件不存在，则创建一个新的文件，如果文件已存在，则会修改文件的时间戳。</li><li><code>cat</code>：<code>cat</code>是英文<code>concatenate</code>的缩写，用于查看文件内容。使用<code>cat</code>查看文件的话，不管文件的内容有多少，都会一次性显示，所以他不适合查看太大的文件。</li><li><code>more</code>：<code>more</code>和<code>cat</code>有点区别，<code>more</code>用于分屏显示文件内容。可以用<code>空格键</code>向下翻页，<code>b</code>键向上翻页</li><li><code>less</code>：和<code>more</code>类似，<code>less</code>用于分行显示</li><li><code>tail</code>：查看日志文件基本。一般用户<code>tail -fn 100 xx.log</code>查看最后的100行内容</li></ol><h3 id="常用的权限命令"><a href="#常用的权限命令" class="headerlink" title="常用的权限命令"></a>常用的权限命令</h3><p><code>chmod</code>：修改权限命令。一般用<code>+</code>号添加权限，<code>-</code>号删除权限，<code>x</code>代表执行权限，<code>r</code>代表读取权限，<code>w</code>代表写入权限，常见写法比如<code>chmod +x 文件名</code> 添加执行权限。<br>还有另外一种写法，使用数字来授权，<code>r=4，w=2，x=1</code>，平时执行命令<code>chmod 777 </code>文件名这就是最高权限了。为什么有3个数字呢？第一个数字代表<code>所有者的权限</code>，第二个数字代表所属组的权限，第三个数字代表<code>其他人的权限</code>。</p><p>常见的如：</p><ul><li>777-最高权限</li><li>644-所有者有读写权限，其他人只有只读权限</li><li>755-其他人有只读和执行权限</li></ul><p><code>chown</code>：用于修改文件和目录的所有者和所属组。一般用法<code>chown user 文件</code>用于修改文件所有者，<code>chown user:user 文件</code>修改文件所有者和组，冒号前面是所有者，后面是组。</p><h3 id="常用的压缩命令"><a href="#常用的压缩命令" class="headerlink" title="常用的压缩命令"></a>常用的压缩命令</h3><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p><code>zip xxx.zip 文件</code><br><code>zip xxx.zip -r 文件夹</code></p><p><code>unzip xxx.zip</code><br><code>unzip xxx.zip -d xxx</code>解压到直接目录</p><p>gzip：用于压缩.gz后缀文件，gzip命令不能打包目录<br>需要注意的是：<code>gzip 文件名</code>源文件会消失，如果要保留源文件，可以使用<code>gzip -c 文件名 &gt; xx.gz</code></p><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>使用命令<code>tar -zcvf xx.tar.gz</code> 文件来打包压缩，使用命令<code>tar -zxvf xx.tar.gz</code>来解压缩<br>参数含义：<code>-x</code>解打包，<code>-c</code>打包，<code>-f</code>指定压缩包文件名，<code>-v</code>显示打包文件过程，<code>-z</code>打包并且压缩。</p><h2 id="top、w、uptime"><a href="#top、w、uptime" class="headerlink" title="top、w、uptime"></a>top、w、uptime</h2><p>都可以用于查看CPU的平均负载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">top - 18:07:21 up 13 days,  2:53,  5 users,  load average: 0.02, 0.02, 0.00</span><br><span class="line">Tasks: 111 total,   1 running, 110 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  0.2 us,  0.2 sy,  0.0 ni, 99.7 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">MiB Mem :   1890.1 total,    191.1 free,    201.9 used,   1497.1 buff/cache</span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used.   1507.9 avail Mem </span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                           </span><br><span class="line">    690 root      10 -10  115868  24296  17660 S   0.7   1.3 120:15.43 AliYunDunMonito                                                   </span><br><span class="line">   3277 root      20   0 1356252  45544  32816 S   0.3   2.4  29:25.53 containerd                                                        </span><br><span class="line">      1 root      20   0  103420  12376   8248 S   0.0   0.6   0:11.92 systemd                                                           </span><br><span class="line">      2 root      20   0       0      0      0 S   0.0   0.0   0:00.10 kthreadd                                                          </span><br><span class="line">      3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp                                                            </span><br></pre></td></tr></table></figure><p><strong>CPU 利用率</strong>：和负载不同，CPU利用率指的是当前正在运行的进程实时占用CPU的百分比，他是对一段时间内CPU使用状况的统计。<br><strong>Load Average</strong> ：负载的3个数字，比如上图的0.02，0.02，0.00，分别代表系统在过去的1分钟，5分钟，15分钟内的系统平均负载。</p><p>如果单核CPU的话，负载达到1就代表CPU已经达到满负荷的状态了，超过1，后面的进行就需要排队等待处理了。</p><p>如果是是多核多CPU的话，假设现在服务器是2个CPU，每个CPU2个核，那么总负载不超过4都没什么问题。</p><p>如何查看CPU核数？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看CPU的情况。</span><br><span class="line">root@sztu202100203017:~# cat /proc/cpuinfo | grep &quot;model name&quot;</span><br><span class="line">model name: Intel(R) Xeon(R) Platinum</span><br><span class="line">model name: Intel(R) Xeon(R) Platinum</span><br><span class="line"># 查看CPU的核数</span><br><span class="line">root@sztu202100203017:~# cat /proc/cpuinfo | grep &quot;cpu cores&quot;</span><br><span class="line">cpu cores: 1</span><br><span class="line">cpu cores: 1</span><br></pre></td></tr></table></figure><h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><p>lsof 是 List Open File 的缩写, 它主要用来获取被进程打开文件的信息</p><h3 id="u"><a href="#u" class="headerlink" title="u"></a>u</h3><p><code>lsof -u jannan</code> :命令表示列出 jannan 用户已经打开了的文件<br><code>lsof -u ^jannan </code> :命令表示列出除 jannan 用户已经打开了的文件</p><h3 id="i"><a href="#i" class="headerlink" title="i"></a>i</h3><ol><li><code>lsof -i</code>:列出所有打开了的网络文件</li><li><code>lsof -i 4</code>:列出所有已经打开了的 ipv4 网络文件</li><li><code>lsof -i 6</code>:列出所有已经打开了的 ipv6 网络文件</li><li><code>lsof -i:端口号</code>:列出在指定端口上打开的文件</li><li><code>lsof -i TCP/UDP</code> 列出使用了TCP 或 UDP 协议的文件</li><li><code>lsof -i TCP:3306</code> 列出使用了TCP 协议并且端口为3306的文件</li></ol><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><ul><li>安装 <code>apt-get install openssh-server</code></li><li>查询ssh服务 <code>ps -e | grep ssh</code></li><li>查询状态 <code>/etc/init.d/ssh status</code></li><li>启动 <code>/etc/init.d/ssh start</code></li><li>开机自启动 <code>systemctl enable ssh</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/post/e255a10a.html"/>
      <url>/post/e255a10a.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>来自飞书文档</p></blockquote><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><a href="https://q1uvhfqqat0.feishu.cn/drive/folder/VDttfMKhClqN1BdqvtQcCfEFn1f">计算机网络</a></h1><h2 id="计算机网络与互联网概述"><a href="#计算机网络与互联网概述" class="headerlink" title="计算机网络与互联网概述"></a><a href="https://q1uvhfqqat0.feishu.cn/docx/O2n5dVMVTo6qtQxUWMCcFAmpnEc">计算机网络与互联网概述</a></h2><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a><a href="https://q1uvhfqqat0.feishu.cn/docx/Zarkd3Av8o1Wp4xCzPaccXJWnmh">物理层</a></h2><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a><a href="https://q1uvhfqqat0.feishu.cn/docx/K0CFdmJxIoFtsnxFSaTcawjvn0b">数据链路层</a></h2>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/post/54e1373e.html"/>
      <url>/post/54e1373e.html</url>
      
        <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="Mysql体系结构"><a href="#Mysql体系结构" class="headerlink" title="Mysql体系结构"></a>Mysql体系结构</h3><ol><li>连接层</li><li>服务层</li><li>引擎层</li><li>存储层</li></ol><h3 id="存储引擎介绍"><a href="#存储引擎介绍" class="headerlink" title="存储引擎介绍"></a>存储引擎介绍</h3><p>存储引擎位于体系结构的引擎层<br>存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可以被叫做表类型。</p><p>MySQL 中常用的四种存储引擎分别是：MyISAM、InnoDB、MEMORY、ARCHIVE。<code>MySQL 5.5</code> 版本后默认的存储引擎为<code>InnoDB</code>。</p><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>高可靠性、高性能</p><ol><li>DML（数据操作）遵循ACID模型，支持<code>事务</code></li><li><code>行级锁</code>，提高并发访问性能</li><li>支持<code>外键</code>FOREIGN KEY约束，保证数据的完整和正确</li></ol><p>结构：TableSpace -&gt; Segement -&gt; Extent(1M) -&gt; Page(16K) -&gt; Row </p><h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>MySQL早期默认的存储引擎</p><ol><li>不支持事务、不支持外键</li><li>支持表锁、不支持行锁</li><li>访问速度快</li></ol><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>表数据存储在内存中，受到硬件、断电影响，只能将这些表作为临时表或缓存使用。</p><ol><li>内存存放</li><li>hash索引（默认）</li></ol><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul><li>InnoDB：对事物的完整性有比较高的需求，在并发条件下要求数据一致性，数据操作除了插入和查询之外，还包含很多更新、删除操作。</li><li>MyISAM：数据操作以查询、插入为主，很少更新和删除，并且对事务的完整性、并发性要求不是很高。（电商：评论、足迹… 但是可以被MongoDB取代</li><li>MEMORY：缓存 但是可以被redis取代</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>index，帮助MySQL<strong>高效获取数据</strong>的<strong>数据结构</strong>（<strong>有序</strong>）。</p><p>所以说，数据库系统除数据之外，还维护着满足特点查询算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><ul><li>优点：高效获取数据，减低IO成本、降低数据排序成本，降低CPU的消耗。</li><li>缺点：占用磁盘空间，减低更新表的速度（INSERT、UPDATE、DELETE   [但是影响不大，正常业务查询占比很大。 磁盘目前也很便宜。]</li></ul><p>索引位于存储引擎层</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要有以下几种：</p><ul><li><strong>B+Tree索引</strong></li><li>Hash索引：不支持范围查询 [MEMORY]</li><li>R-tree:地理空间数据类型 [MyISAM]</li><li>Full-test：倒排索引 [InnoDB5.6之后、MyISAM]</li></ul><p>先来说说常见二叉树弊端：如果是顺序插入的话，会形成一个链表[<em>红黑树可以解决</em>]。大数据量情况下，由于只有二叉，层级较深。</p><blockquote><p>B Tree</p></blockquote><p><img src="/./../static/img/image.png" alt="Alt text"></p><blockquote><p>B+Tree</p></blockquote><p><img src="/./../static/img/image1.png" alt="Alt text"></p><blockquote><p>Hash</p></blockquote><p><img src="/./../static/img/image2.png" alt="Alt text"></p><p>特点:</p><ul><li>不支持范围查询</li><li>无法利用索引完成排序操作</li><li>查询效率高,通常只需要一次检索</li></ul><h4 id="为什么InnoDB存储引擎选择B-Tree"><a href="#为什么InnoDB存储引擎选择B-Tree" class="headerlink" title="为什么InnoDB存储引擎选择B+Tree"></a>为什么InnoDB存储引擎选择B+Tree</h4><ol><li>相较于二叉树,层级更少,搜索效率提高(顺序插入导致形成链表) 红黑树？本质还是二叉树。</li><li>相较于B树，无论是叶子节点还是非叶子节点，都会保存数据，导致一页中存储的键值减少，指针跟着减少。若要保存大量数据，只能增加树的高度，导致性能减低。（而在B+树，无论搜索什么数据都需要到最底层，搜索效率稳定。此外叶子节点形成了双向链表，便于范围搜索和排序</li><li>相较于Hash索引，B+树支持范围匹配以及排序操作</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>主键索引 <strong>针对表中主键创建的索引</strong> <code>默认自动创建，只能有一个</code> <strong>PRIMARY</strong></li><li>唯一索引 <strong>避免同一个表中某数据列中的值重复</strong> <code>可以有多个</code> <strong>UNIQUE</strong></li><li>常规索引 <strong>快读定位特点数据</strong> <code>可以有多个</code></li><li>全文索引 <strong>全文索引查找的是文本中的关键字，而不是比较索引中的值</strong> <code>可以有多个</code> <strong>FULLTEXT</strong></li></ol><p>在InnoDB，根据索引的存储形式，分为以下两种</p><ol><li>聚集索引 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 <code>必须有，而且只有一个</code></li><li>二级索引 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 <code>可以存在多个</code></li></ol><p>聚集索引的选取规则：</p><ul><li>存在主键，主键索引就是聚集索引</li><li>不存在主键，将使用的第一个唯一（<code>UNIQUE</code>）索引作为聚集索引</li><li>都没有？InnoDB会自动生成一个<code>rowid</code>作为隐藏的聚集索引</li></ul><p>（</p><ul><li>聚集索引：其叶子节点下面挂的数据就是<code>该行对应的数据</code></li><li>二级索引：其叶子节点下面挂的数据就是<code>该行对应的ID（主键值</code></li></ul><p>过程：<code>回表查询</code><br>假设有<code>user</code>表，字段<code>id</code>为聚集索引、字段<code>name</code>为二级索引，现在执行<code>select * from user where name = &#39;Arm&#39;</code></p><ol><li>首先，进行<code>name</code>字段的二级索引，找到Arm<code>该行对应的ID</code></li><li>其次，进行<code>id</code>字段的聚集索引，找到<code>该行对应的数据</code><br> ）</li></ol><h4 id="执行效率？"><a href="#执行效率？" class="headerlink" title="执行效率？"></a>执行效率？</h4><p>下面哪个语句执行效率高？</p><ol><li><code>select * from user where name = &#39;Arm&#39;</code> name字段创建的有索引</li><li><code>select * from user where id = 10</code> id为主键<br>必然是2，根据name字段查，先经过二级索引，再是聚集索引。需要进行回表查询</li></ol><h4 id="InnoDB主键索引的B-Tree高度？"><a href="#InnoDB主键索引的B-Tree高度？" class="headerlink" title="InnoDB主键索引的B+Tree高度？"></a>InnoDB主键索引的B+Tree高度？</h4><ul><li>一个页大小是固定的，16K</li></ul><p>了解：InnoDB B+树的高度很矮，却能存储海量数据</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><code>CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name, ...)</code></p><ul><li>一个索引关联一个字段，称为单列索引</li><li>一个索引关联多个字段，称为联合索引（组合索引</li></ul><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p><code>SHOW INDEX FROM table_name</code></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><code>DROP INDEX index_name ON table_name</code></p><h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><h4 id="SQL执行频率"><a href="#SQL执行频率" class="headerlink" title="SQL执行频率"></a>SQL执行频率</h4><p><code>show global status likes &#39;Com_______&#39;</code>;<br>可以看到</p><ul><li>Com_insert</li><li>Com_select</li><li>Com_delete</li><li>Com_update 等信息，分别对应的次数，即可得出该数据库什么业务占比较大，然后针对问题进行具体的优化</li></ul><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认是没有开启的，需要在MySQL的配置文件<code>/etc/my.conf</code>中配置如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 开启MySQL慢日志查询开关</span><br><span class="line">slow_query_log=1</span><br><span class="line"># 设置慢日志时间为2秒</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure><p>配置完毕后需要重启MySQL服务器，在<code>/var/lib/mysql/localhost-slow.log</code>查看慢日志文件</p><ul><li>查询是否开启：<code>show variables like &#39;slow_query_log&#39;</code></li></ul><h4 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h4><ul><li>是否支持 <code>select @@have_profiling</code></li><li>默认是关闭的，通过set语句在session&#x2F;global级别开启：<code>select @@profiling</code>看看是否开启；执行<code>set profiling = 1</code>开启。<br>下面是查看流程：</li></ul><ol><li>通过<code>show profiles</code>查看前面执行过的查询语句的详情</li><li><code>show profile for query query_id</code> 查看指定query_id的SQL语句各个阶段耗时情况</li><li><code>show profile cpu for query query_id</code> CPU使用情况</li></ol><h4 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h4><p>MySQL如何执行SELECT语句的信息，包括执行过程如何连接和连接的顺序。<br>直接在<code>SELECT</code>语句前加上<code>EXPLAIN</code></p><ul><li>id 展示表的执行顺序（多表查询。id相同，从上到下；id不同，值越大越先执行</li><li>select_type 查询类型:SIMPLE(没有表连接、子查询)、PRIMARY(主查询)、UNION、SUBQUERY</li><li><strong>type</strong> 访问（连接）类型，<strong>性能由好到坏</strong>：NULL（不使用表）、system（系统表）、const（主键、唯一索引）、eq_ref、ref（使用非唯一性索引）、range（遍历整个索引树）、all（全表扫描）</li><li><strong>possible_key</strong> 显示可能应用在这张表上的索引，可能有多个</li><li><strong>key</strong> 实际使用的索引，没使用则为NULL</li><li><strong>key_len</strong> 表示索引中使用的字节数，根据索引字段最大可能长度，并非实际使用长度，越短越好（不损失精度</li><li>rows 查询的行数（参考值</li><li>filtered 返回结果的行数占需读取行数的百分比，该值越大越好</li><li>ref</li></ul><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引了多列（<strong>联合索引</strong>），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。（如果跳过了，则只有<strong>部分生效</strong>，跳过后面的全部字段索引失效</p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>联合索引中，出现范围查询<code>（&gt;，&lt;）</code>，<strong>范围查询右侧的列索引失效</strong></p><p>如何避免？使用<code>（&gt;=，&lt;=）</code></p><h4 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h4><p>不要在索引列上进行运算操作，否则索引会失效。如<code>substring(phone, 10, 2) = &#39;15&#39;</code>从第十位开始截取2位。</p><h4 id="字符串不加引号"><a href="#字符串不加引号" class="headerlink" title="字符串不加引号"></a>字符串不加引号</h4><p>字符串类型索引字段使用，<strong>不加引号</strong>，索引失效</p><h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部，则失效。前后都加也失效。</p><h4 id="OR连接的条件"><a href="#OR连接的条件" class="headerlink" title="OR连接的条件"></a>OR连接的条件</h4><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h2 id="视图、存储过程、触发器"><a href="#视图、存储过程、触发器" class="headerlink" title="视图、存储过程、触发器"></a>视图、存储过程、触发器</h2><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h2 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h2><h2 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h2><h1 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h1><h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASC  : ascending order  升序</span><br><span class="line">DESC : descending order 降序</span><br></pre></td></tr></table></figure><h2 id="CHAR-LENGTH"><a href="#CHAR-LENGTH" class="headerlink" title="CHAR_LENGTH"></a>CHAR_LENGTH</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 用于判断字符串长度 --&gt;</span><br><span class="line">char_length(str)</span><br></pre></td></tr></table></figure><h2 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h2><ol><li><code>FROM A Inner Join B</code>     ：类似于取A和B的交集，只取满足条件的相交部分。</li><li><code>FROM A Left Join B</code>      ：左连接，以左表A为基础，取A表的全部行，B满足on条件的取对应行，不满足的取NULL。</li><li><code>FROM A Right Join B</code>     ：右连接，以右表B为基础，取B表的全部行，A满足on条件的取对应行，不满足的取NULL。</li><li><code>FROM A Full Outer Join B</code>：类似于取A和B的并集。全都取，但彼此没有对应的值就取NULL。</li><li><code>FROM A CROSS JOIN B</code>     : 交叉连接，即取A和B的笛卡尔积。<blockquote><p>用法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from A left join B on A.id = B.id</span><br><span class="line">where ...</span><br></pre></td></tr></table></figure></li></ol><h2 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF"></a>DATEDIFF</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type : date    </span><br><span class="line">datediff(A.recordDate , B.recordDate) = 1</span><br><span class="line"></span><br><span class="line">// A.recordDate = B.recordDate + 1</span><br></pre></td></tr></table></figure><h2 id="ROUND-AVG"><a href="#ROUND-AVG" class="headerlink" title="ROUND AVG"></a>ROUND AVG</h2><p><code>round(avg(), 3)</code></p><hr><h2 id="ISFULL"><a href="#ISFULL" class="headerlink" title="ISFULL"></a>ISFULL</h2><p>如果值为null，则置为0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isfull(cnt, 0)</span><br></pre></td></tr></table></figure><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><h3 id="MOD"><a href="#MOD" class="headerlink" title="MOD"></a>MOD</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 奇数 --&gt;</span><br><span class="line">mod(id, 2) = 1 </span><br></pre></td></tr></table></figure><h2 id="错题集"><a href="#错题集" class="headerlink" title="错题集"></a>错题集</h2><ol><li><a href="https://leetcode.cn/problems/customer-who-visited-but-did-not-make-any-transactions/">1581. 进店却未进行过交易的顾客</a>：子查询</li><li><a href="https://leetcode.cn/problems/average-time-of-process-per-machine/">1661. 每台机器的进程平均运行时间</a>：avg round</li><li><a href="https://leetcode.cn/problems/rising-temperature">197. 上升的温度</a>：datediff</li><li><a href="https://leetcode.cn/problems/students-and-examinations">1280. 学生们参加各科测试的次数</a>：交叉连接、ifnull</li><li><a href="https://leetcode.cn/problems/managers-with-at-least-5-direct-reports">570. 至少有5名直接下属的经理</a>：子查询</li><li><a href="https://leetcode.cn/problems/confirmation-rate">1934. 确认率</a>:count 判断语句</li><li><a href="https://leetcode.cn/problems/queries-quality-and-percentage">1211. 查询结果的质量和占比</a>:sum(if([], 1, 0)) &#x3D;&#x3D;&#x3D; count(if([], 1, null))</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-买卖股票的最佳时机</title>
      <link href="/post/2039c2a0.html"/>
      <url>/post/2039c2a0.html</url>
      
        <content type="html"><![CDATA[<h2 id="Ⅰ"><a href="#Ⅰ" class="headerlink" title="Ⅰ"></a>Ⅰ</h2><p>限定只买卖<code>一支</code>股票获得的最大利润</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b&#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    now, res := prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i ++&#123;</span><br><span class="line">        res = max(res, max(<span class="number">0</span>, prices[i] - now))</span><br><span class="line">        now = min(now, prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅱ"><a href="#Ⅱ" class="headerlink" title="Ⅱ"></a>Ⅱ</h2><p>不限定买卖股票的数量获得的最大利润</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b&#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    f := <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, n)</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i ++&#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = max(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">        f[i][<span class="number">1</span>] = max(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h2 id="Ⅲ"><a href="#Ⅲ" class="headerlink" title="Ⅲ"></a>Ⅲ</h2><p>限定只买卖<code>两支</code>股票获得的最大利润</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> maxProfitK(<span class="number">2</span>, prices)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfitK</span><span class="params">(k <span class="type">int</span>, prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b&#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    f := <span class="built_in">make</span>([][][<span class="number">2</span>]<span class="type">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i ++&#123;</span><br><span class="line">        f[i] = <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= k; j ++&#123;</span><br><span class="line">            f[i][j] = [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">-0x3f3f3f3f</span>, <span class="number">-0x3f3f3f3f</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i ++&#123;</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i ++&#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= k; j ++&#123;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = max(f[i - <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>]     + prices[i - <span class="number">1</span>])</span><br><span class="line">            f[i][j][<span class="number">1</span>] = max(f[i - <span class="number">1</span>][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= k; i ++&#123;</span><br><span class="line">        res = max(res, f[n][i][<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅳ"><a href="#Ⅳ" class="headerlink" title="Ⅳ"></a>Ⅳ</h2><p>限定只买卖<code>k支</code>股票获得的最大利润</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(k <span class="type">int</span>, prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a &gt; b&#123;</span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    f := <span class="built_in">make</span>([][][<span class="number">2</span>]<span class="type">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i ++&#123;</span><br><span class="line">        f[i] = <span class="built_in">make</span>([][<span class="number">2</span>]<span class="type">int</span>, k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= k; j ++&#123;</span><br><span class="line">            f[i][j] = [<span class="number">2</span>]<span class="type">int</span>&#123;<span class="number">-0x3f3f3f3f</span>, <span class="number">-0x3f3f3f3f</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= n; i ++&#123;</span><br><span class="line">        f[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i ++&#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= k; j ++&#123;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = max(f[i - <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>]     + prices[i - <span class="number">1</span>])</span><br><span class="line">            f[i][j][<span class="number">1</span>] = max(f[i - <span class="number">1</span>][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - prices[i - <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= k; i ++&#123;</span><br><span class="line">        res = max(res, f[n][i][<span class="number">0</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-二叉树</title>
      <link href="/post/5f55cfd6.html"/>
      <url>/post/5f55cfd6.html</url>
      
        <content type="html"><![CDATA[<h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val   <span class="type">int</span></span><br><span class="line">    Left  *TreeNode</span><br><span class="line">    Right *TreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res []<span class="type">int</span></span><br><span class="line">    <span class="keyword">var</span> inorder <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">    inorder = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">nil</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root.Left)</span><br><span class="line">        res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">        inorder(root.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goland</title>
      <link href="/post/31b9712f.html"/>
      <url>/post/31b9712f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Goland"><a href="#Goland" class="headerlink" title="Goland"></a>Goland</h1><h2 id="常用链接"><a href="#常用链接" class="headerlink" title="常用链接"></a>常用链接</h2><ul><li><a href="http://mian.topgoer.com/">面试题</a></li><li><a href="https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/">中文文档</a></li><li><a href="https://golang.halfiisland.com/">Goland中文学习文档</a></li></ul><hr><h2 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h2><ul><li>进程：资源分配的基本单位</li><li>线程：进程中的执行单元，CPU调度的基本单位。除了一些必要的堆栈空间其他资源都是共享的。</li><li>协程：用户态的协程，可以通过用户程序创建，删除。~~~协程切换时不需要切换内核态~~~</li></ul><h3 id="线程共享的资源"><a href="#线程共享的资源" class="headerlink" title="线程共享的资源"></a>线程共享的资源</h3><ol><li>文件描述符：进程打开的文件描述符是进程级别的 通一个进程中的线程可以共享打开的文件描述符 同时读写一个文件</li><li>内存空间：全局变量和静态变量</li><li>代码段、数据段和堆栈段</li></ol><h3 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h3><ol><li>线程是操作系统的概念，而协程是程序级的概念。线程由操作系统调度执行，每个线程都有自己的执行上下文，包<br>括程序计数器、寄存器等。而协程由程序自身控制。</li><li>多个线程之间通过切换执行的方式实现并发。线程切换时需要保存和恢复<strong>完整</strong>上下文，涉及到上下文切换的开销（用户态和内核态切换）。而协程切换时不需要操作系统的介入，只需要保存和恢复自身的上下文，切换开销较小（用户态）。</li></ol><hr><h2 id="new和make的区别"><a href="#new和make的区别" class="headerlink" title="new和make的区别"></a>new和make的区别</h2><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><ul><li>分配类型：slice、map、chan</li><li>返回：返回该对象本身</li></ul><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ul><li>分配类型：所有</li><li>返回：指针</li></ul><hr><h2 id="切片和数组的区别"><a href="#切片和数组的区别" class="headerlink" title="切片和数组的区别"></a>切片和数组的区别</h2><h3 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h3><p>数组：是同一种数据类型的<strong>固定长度</strong>的序列。</p><p>长度是数组类型的一部分。</p><p>数组是值类型，赋值和传参会复制整个数组，而不是指针。改变副本不会影响自身。 支持&#x3D;&#x3D; !&#x3D;</p><h3 id="切片Slice"><a href="#切片Slice" class="headerlink" title="切片Slice"></a>切片Slice</h3><p>切片：是数组的一个引用，切片是引用类型。<strong>值拷贝传递</strong></p><p>切片的长度可以改变，因此切片是<strong>可变长</strong>数组</p><p>slice &#x3D; nil 则cap len &#x3D; 0</p><hr><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><code>map</code>是一种无序的基于<code>key-value</code>的数据结构，Go语言中的<code>map</code>是<strong>引用类型</strong>，<em>必须初始化才能使用</em>。</p><hr><h2 id="init函数和main函数"><a href="#init函数和main函数" class="headerlink" title="init函数和main函数"></a>init函数和main函数</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p><code>init</code>函数用于包（<code>package</code>）的初始化，在<code>main</code>函数执行前执行。</p><ul><li>init函数不能被其他函数调用</li><li>按照包导入的依赖关系决定该初始化函数的执行顺序</li></ul><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>入口函数</p><h3 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h3><ul><li>相同：两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用。</li><li>不同：<ul><li>init可以应用于任意包中，且可以重复定义多个。</li><li>main函数只能用于main包中，且只能定义一个。</li></ul></li></ul><p>执行顺序？</p><ul><li>对同一个go文件的init()调用顺序是从上到下的。</li><li>对同一个package中不同文件是按文件名字符串比较“从小到大”顺序调用各文件中的init()函数。</li><li>对于不同的package，如果不相互依赖的话，按照main包中”先import的后调用”的顺序调用其包中的init()，如果package存在依赖，则先调用最早被依赖的package中的init()，最后调用main函数。</li></ul><hr><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Lamda表达式，函数 + 环境引用 &#x3D; 闭包</p><hr><h2 id="延迟调用defer"><a href="#延迟调用defer" class="headerlink" title="延迟调用defer"></a>延迟调用defer</h2><p>defer关键字描述的一个匿名函数会在函数返回之前执行</p><p>延迟调用通常用于释放文件资源，关闭连接等操作，另一个常用的写法是用于捕获panic</p><p>当有多个defer语句时，会按照后进先出的顺序执行。</p><hr><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   set := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">set[v] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> num := <span class="keyword">range</span> set &#123;</span><br><span class="line">       <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queue []<span class="type">int</span></span><br><span class="line">queue = <span class="built_in">append</span>(queue, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(queue) &gt; <span class="number">1</span> &#123;</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue := list.New()</span><br><span class="line">queue.PushBack(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> queue.Len() &gt; <span class="number">1</span> &#123;</span><br><span class="line">queue.Remove(queue.Front())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通优先队列 小根堆</span></span><br><span class="line"><span class="keyword">type</span> MinHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Len() <span class="type">int</span>              &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span>    &#123; <span class="keyword">return</span> h[i] &lt; h[j] &#125; <span class="comment">// 这里大于就是大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Swap(i, j <span class="type">int</span>)         &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MinHeap)</span></span> Top() <span class="type">int</span>              &#123; <span class="keyword">return</span> h[<span class="number">0</span>] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Push(num <span class="keyword">interface</span>&#123;&#125;) &#123; *h = <span class="built_in">append</span>(*h, num.(<span class="type">int</span>)) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MinHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="comment">// 调用这个函数之前 会调用heap.Pop 将堆顶移除放到最后 因此这里返回的是最后一个元素</span></span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(*h)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[:n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于pair</span></span><br><span class="line"><span class="keyword">type</span> IHeap [][<span class="number">2</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IHeap)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i][<span class="number">1</span>] &lt; h[j][<span class="number">1</span>] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IHeap)</span></span> Swap(i, j <span class="type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.([<span class="number">2</span>]<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[:n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(distance, original)</span><br></pre></td></tr></table></figure><h3 id="append数组"><a href="#append数组" class="headerlink" title="append数组"></a>append数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1 = <span class="built_in">append</span>(list1, list2...)</span><br></pre></td></tr></table></figure><h3 id="对数组进行排序"><a href="#对数组进行排序" class="headerlink" title="对数组进行排序"></a>对数组进行排序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line">sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> nums[i] &lt; nums[j] &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="sort包"><a href="#sort包" class="headerlink" title="sort包"></a>sort包</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort.Search(len(xxx传入切片), func(i int) bool &#123;return xxx传入条件&#125;)</span></span><br><span class="line"><span class="comment">// 找到第一个&gt;= target的数的下标，找不到则返回len(nums)</span></span><br><span class="line">idx := sort.Search(<span class="built_in">len</span>(nums), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;<span class="keyword">return</span> nums[i] &gt;= target&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort.SearchInts</span></span><br><span class="line"><span class="comment">// sort.SearchInts中调用了sort.Search，传入的函数为 nums[i] &gt;= target</span></span><br><span class="line"><span class="comment">// 很明显 即找到第一个大于等于target的数的下标，找不到则返回len(nums)</span></span><br><span class="line">idx := sort.SearchInts(nums, target)</span><br></pre></td></tr></table></figure><blockquote><p>前面展示的好像都是找到<code>第一个...的数</code>，那如果我想找到<code>最后一个...的数</code>呢？其实很简单</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort.SearchInts(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line"><span class="comment">// 即可实现</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接序列化结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">UserName <span class="type">string</span> <span class="string">`json:&quot;user_name&quot;`</span></span><br><span class="line">Phone    <span class="type">string</span> <span class="string">`json:&quot;phone,omitempty&quot;`</span> <span class="comment">// 抛弃空值</span></span><br><span class="line">PassWord <span class="type">string</span> <span class="string">`json:&quot;-&quot;`</span> <span class="comment">// 忽略该字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user := &amp;User&#123;</span><br><span class="line">UserName: <span class="string">&quot;Jan_Nan&quot;</span>,</span><br><span class="line">Phone:    <span class="string">&quot;18126934563&quot;</span>,</span><br><span class="line"><span class="comment">// 若没有赋值，则显示默认零值</span></span><br><span class="line">&#125;</span><br><span class="line">data, _ := json.Marshal(user)</span><br><span class="line">fmt.Println(<span class="type">string</span>(data))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Technical-Interview</title>
      <link href="/post/c2b639f4.html"/>
      <url>/post/c2b639f4.html</url>
      
        <content type="html"><![CDATA[<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><p>唯一标识的字段</p><h4 id="主键、外键、索引的区别"><a href="#主键、外键、索引的区别" class="headerlink" title="主键、外键、索引的区别"></a>主键、外键、索引的区别</h4><ul><li>定义<ul><li>主键：唯一标识一条记录（不重复、不可为空</li><li>外键：另一张表的主键（可重复、可为空</li><li>索引：（不重复，可为空</li></ul></li><li>作用<ul><li>主键：保持数据完整性</li><li>外键：与其他表建立联系</li><li>索引：提高查询排序的速度</li></ul></li></ul><h4 id="表优化"><a href="#表优化" class="headerlink" title="表优化"></a>表优化</h4><ol><li>使用tinyint、smallint、mediumint代替int，若非负则加上unsigned</li><li>varchar长度只分配真正需要的空间</li><li>尽量使用整数或枚举代替字符串类型</li><li>时间使用timestamp而不是datetime</li><li>单表不要放太多字段</li><li>少使用null，很难查询优化而且占用额外索引空间</li></ol><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>什么是慢查询：设置指定超时时间（long_query_time），超过这个时间的sql语句称为慢查询。默认为10秒</p><p>如何优化？</p><p>待补充…</p><h3 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态</li><li><strong>一致性（Consistency）</strong>：事务操作前和操作后，<del>数据满足完整性约束，</del> 数据库保持一致性状态。</li><li><strong>隔离性（Isolation）</strong>：多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h4 id="脏读、不可重复读、幻读"><a href="#脏读、不可重复读、幻读" class="headerlink" title="脏读、不可重复读、幻读"></a>脏读、不可重复读、幻读</h4><ul><li><strong>脏读</strong>：一个事务「读到」了另一个「未提交事务修改过的数据」。</li><li><strong>不可重复读</strong>：在一个事务内多次读取同一个数据，出现前后两次读到的数据不一样的情况。</li><li><strong>幻读</strong>：在一个事务内多次查询某个符合查询条件的「记录数量」，出现前后两次查询到的记录数量不一样的情况。</li></ul><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul><li>脏读：读到其他事务未提交的数据；</li><li>不可重复读：前后读取的数据不一致；</li><li>幻读：前后读取的记录数量不一致。</li></ul><p>隔离级别越高，性能效率就越低</p><ul><li>读未提交：指一个事务还未提交时，它做的变更就能被其他事务看到。导致1 2 3</li><li>读提交：指一个事务提交后，它做的变更才能被其他事务看到。导致2 3</li><li>可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySql InnoDB 引擎的默认隔离级别</strong>。导致3</li><li>串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><h5 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h5><ul><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于<strong>创建 Read View 的时机不同</strong>。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。</li></ul><h4 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h4><ol><li>完整性约束</li></ol><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣-链表</title>
      <link href="/post/17062.html"/>
      <url>/post/17062.html</url>
      
        <content type="html"><![CDATA[<h2 id="用到的数据结构"><a href="#用到的数据结构" class="headerlink" title="用到的数据结构"></a>用到的数据结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带随机指针的链表"><a href="#带随机指针的链表" class="headerlink" title="带随机指针的链表"></a>带随机指针的链表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Val <span class="type">int</span></span><br><span class="line">    Next *ListNode</span><br><span class="line">    Random *ListNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206 反转链表"></a>206 反转链表</h2><p>假设目前有 <code>prev</code> <code>curr</code> <code>next</code> 三个指针，关系如下：<code>prev</code> -&gt; <code>curr</code> -&gt; <code>next</code>。</p><p>遍历链表，把当前节点<code>curr</code>的Next指向前一个节点<code>prev</code>，即<code>curr.Next = prev</code>。</p><p>需要注意的细节：</p><ol><li>当<code>curr == head</code>时，<code>prev</code>自然为空。因此<code>prev</code>初始化为<code>nil</code>即可。</li><li>循环结束条件<code>curr != nil</code>，此时<code>prev</code>为最后一个节点，因此函数返回是<code>prev</code>。再者说循环结束条件也可以改成<code>pre != tail</code>，<code>tail</code>指的是最后一个节点，此题没有给出<code>tail</code>，下一道题会用到。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">var</span> prev *ListNode</span><br><span class="line">    curr := head</span><br><span class="line">    <span class="keyword">for</span> curr != <span class="literal">nil</span>&#123;</span><br><span class="line">        next := curr.Next</span><br><span class="line">        curr.Next = prev</span><br><span class="line">        prev = curr</span><br><span class="line">        curr = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="25-K个一组反转链表"><a href="#25-K个一组反转链表" class="headerlink" title="25 K个一组反转链表"></a>25 K个一组反转链表</h2><p>遍历链表</p><ul><li>每次找到一组距离为<code>k</code>的子链表的<code>head</code>和<code>tail</code>，反转子链表即可。</li><li>长度不出<code>k</code>退出即可</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="comment">// 给定head tail 反转链表</span></span><br><span class="line">    reverse := <span class="function"><span class="keyword">func</span><span class="params">(head, tail *ListNode)</span></span> (*ListNode, *ListNode) &#123;</span><br><span class="line">        prev := tail.Next <span class="comment">// // head要指向tail.Next故初始化为tail.Next</span></span><br><span class="line">        curr := head</span><br><span class="line">        <span class="keyword">for</span> prev != tail&#123;</span><br><span class="line">            next := curr.Next</span><br><span class="line">            curr.Next = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail, head</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hair := &amp;ListNode&#123;<span class="number">0</span>, head&#125; <span class="comment">// 设定一个虚假的头指针</span></span><br><span class="line">    prev := hair</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span>&#123;</span><br><span class="line">        tail := prev</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i ++&#123;</span><br><span class="line">            tail = tail.Next</span><br><span class="line">            <span class="keyword">if</span> tail == <span class="literal">nil</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> hair.Next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next := tail.Next</span><br><span class="line">        head, tail = reverse(head, tail)</span><br><span class="line">        prev.Next = head</span><br><span class="line">        tail.Next = next</span><br><span class="line"></span><br><span class="line">        prev = tail</span><br><span class="line">        head = tail.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hair.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138 随机链表的复制"></a>138 随机链表的复制</h2><p>递归创建子节点，map维护已创建过的节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mp <span class="keyword">map</span>[*Node]*Node</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(node *Node)</span></span> *Node&#123;</span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n, ok := mp[node]; ok&#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    newNode := &amp;Node&#123;node.Val, <span class="literal">nil</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    mp[node] = newNode</span><br><span class="line">    newNode.Next = dfs(node.Next)</span><br><span class="line">    newNode.Random = dfs(node.Random)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span></span> *Node &#123;</span><br><span class="line">    mp = <span class="keyword">map</span>[*Node]*Node&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21 合并两个有序链表"></a>21 合并两个有序链表</h2><p>双指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    res := &amp;ListNode&#123;<span class="number">0</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    cur := res</span><br><span class="line">    <span class="keyword">for</span> list1 != <span class="literal">nil</span> &amp;&amp; list2 != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> list1.Val &lt;= list2.Val&#123;</span><br><span class="line">            cur.Next = list1</span><br><span class="line">            list1 = list1.Next</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur.Next = list2</span><br><span class="line">            list2 = list2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> list1 != <span class="literal">nil</span>&#123;</span><br><span class="line">        cur.Next = list1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> list2 != <span class="literal">nil</span>&#123;</span><br><span class="line">        cur.Next = list2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h2><ul><li>归并排序</li><li>合并两个有序链表</li><li>快慢指针找<code>mid</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(l, r *ListNode)</span></span> *ListNode&#123;</span><br><span class="line">    res  := &amp;ListNode&#123;<span class="number">0</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    curr := res</span><br><span class="line">    <span class="keyword">for</span> l != <span class="literal">nil</span> &amp;&amp; r != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> l.Val &lt;= r.Val&#123;</span><br><span class="line">            curr.Next = l</span><br><span class="line">            l = l.Next</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            curr.Next = r</span><br><span class="line">            r = r.Next</span><br><span class="line">        &#125;</span><br><span class="line">        curr = curr.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l != <span class="literal">nil</span>&#123;</span><br><span class="line">        curr.Next = l</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r != <span class="literal">nil</span>&#123;</span><br><span class="line">        curr.Next = r</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.Next</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head <span class="comment">// 递归的出口，不用排序 直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="keyword">var</span> prev *ListNode <span class="comment">// 用于保存slow前一个节点 slow为mid</span></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span>&#123; <span class="comment">// 快慢指针找mid </span></span><br><span class="line">        prev = slow</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    prev.Next = <span class="literal">nil</span> <span class="comment">// 将list分成两半</span></span><br><span class="line">    l := sortList(head)</span><br><span class="line">    r := sortList(slow)</span><br><span class="line">    <span class="keyword">return</span> merge(l, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a>23. 合并 K 个升序链表</h2><ul><li>合并两个有序链表  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    res := &amp;ListNode&#123;<span class="number">0</span>, <span class="literal">nil</span>&#125;</span><br><span class="line">    cur := res</span><br><span class="line">    <span class="keyword">for</span> list1 != <span class="literal">nil</span> &amp;&amp; list2 != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> list1.Val &lt;= list2.Val&#123;</span><br><span class="line">            cur.Next = list1</span><br><span class="line">            list1 = list1.Next</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            cur.Next = list2</span><br><span class="line">            list2 = list2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> list1 != <span class="literal">nil</span>&#123;</span><br><span class="line">        cur.Next = list1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> list2 != <span class="literal">nil</span>&#123;</span><br><span class="line">        cur.Next = list2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法一-暴力"><a href="#方法一-暴力" class="headerlink" title="方法一 暴力"></a>方法一 暴力</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    res := lists[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(lists); i ++&#123;</span><br><span class="line">        res = mergeTwoLists(res, lists[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-分治"><a href="#方法二-分治" class="headerlink" title="方法二 分治"></a>方法二 分治</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lists) == <span class="number">1</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    l := mergeKLists(lists[:<span class="built_in">len</span>(lists) / <span class="number">2</span>])</span><br><span class="line">    r := mergeKLists(lists[<span class="built_in">len</span>(lists) / <span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(l, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-优先队列"><a href="#方法三-优先队列" class="headerlink" title="方法三 优先队列"></a>方法三 优先队列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LRUCache <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="type">int</span></span><br><span class="line">    capacity   <span class="type">int</span></span><br><span class="line">    cache      <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode</span><br><span class="line">    head, tail *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DLinkedNode <span class="keyword">struct</span>&#123;</span><br><span class="line">    key, value <span class="type">int</span></span><br><span class="line">    prev, next *DLinkedNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(capacity <span class="type">int</span>)</span></span> LRUCache &#123;</span><br><span class="line">    l := LRUCache&#123;</span><br><span class="line">        cache    : <span class="keyword">map</span>[<span class="type">int</span>]*DLinkedNode&#123;&#125;,</span><br><span class="line">        head     : InitDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        tail     : InitDLinkedNode(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">        capacity : capacity,</span><br><span class="line">    &#125;</span><br><span class="line">    l.head.next = l.tail</span><br><span class="line">    l.tail.next = l.head</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Get(key <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := this.cache[key]; !ok&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    node := this.cache[key]</span><br><span class="line">    this.moveToHead(node)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> Put(key <span class="type">int</span>, value <span class="type">int</span>)  &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := this.cache[key]; !ok&#123;</span><br><span class="line">        node := InitDLinkedNode(key, value)</span><br><span class="line">        this.cache[key] = node</span><br><span class="line">        this.addToHead(node)</span><br><span class="line">        this.size ++</span><br><span class="line">        <span class="keyword">if</span> this.size &gt; this.capacity&#123;</span><br><span class="line">            removed := this.removeTail()</span><br><span class="line">            <span class="built_in">delete</span>(this.cache, removed.key)</span><br><span class="line">            this.size --</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        node := this.cache[key]</span><br><span class="line">        node.value = value</span><br><span class="line">        this.moveToHead(node)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDLinkedNode</span><span class="params">(key, value <span class="type">int</span>)</span></span> *DLinkedNode&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DLinkedNode&#123;</span><br><span class="line">        key:   key,</span><br><span class="line">        value: value,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> addToHead(node *DLinkedNode)&#123;</span><br><span class="line">    node.prev = this.head</span><br><span class="line">    node.next = this.head.next</span><br><span class="line">    this.head.next.prev = node</span><br><span class="line">    this.head.next = node</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> moveToHead(node *DLinkedNode)&#123;</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    this.addToHead(node)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeTail() *DLinkedNode&#123;</span><br><span class="line">    node := this.tail.prev</span><br><span class="line">    this.removeNode(node)</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *LRUCache)</span></span> removeNode(node *DLinkedNode)&#123;</span><br><span class="line">    node.prev.next = node.next</span><br><span class="line">    node.next.prev = node.prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>何为消息队列</title>
      <link href="/post/f13964c7.html"/>
      <url>/post/f13964c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="何为消息队列？"><a href="#何为消息队列？" class="headerlink" title="何为消息队列？"></a>何为消息队列？</h1><p>消息队列（MQ），指保持消息的一个容器，本质是个队列。但这个队列需要支持<strong>高吞吐</strong>、<strong>高并发</strong>、<strong>高可用</strong>。</p><h2 id="常见消息队列对比"><a href="#常见消息队列对比" class="headerlink" title="常见消息队列对比"></a>常见消息队列对比</h2><ul><li>Kafka：分布式的、分区的、多副本的日志提交服务，在高吞吐场景下发挥较为出色。</li><li>RockerMQ：低延迟、强一致、高性能、高可靠、亿万级容量和灵活的可拓展性，在一些实用场景中运用较广。</li><li>Pulsar：是下一代云原生分布式消息流平台，集消息、存储、轻量化函数式计算为一体、采用存算分离的架构设计。</li><li>BMQ：和Pubsar架构类似，存算分离，初期定位是承接高吞吐的离线业务场景，逐步替换掉对应的Kafka集群。</li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>离线消息处理中：日志信息、Metrics数据（程序状态、性能采集）、用户行为（搜索、点赞、评论、收藏）</p><p>搜索服务、直播服务、订单服务、支付服务</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol><li>采集集群</li><li>新增Topic</li><li>编写生产者逻辑</li><li>编写消费者逻辑</li></ol><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>Topic：逻辑队列，不同Topic可以建立不用Topic（业务场景，所有数据都存储在这个业务中）</li><li>Cluster：物理集群，每个集群中可以建立多个不同的Topic</li><li>Producer：生产者，负责将业务消息发送到Topic中</li><li>Consumer：消费者，负责消费Topic中的消息</li><li>ConsumerGroup：消费者组，不同组Consumer消费进度互不干涉</li><li>Partition：将Topic分区，不同分区可以并发处理</li><li>offset：消息在partition内的相对位置信息，可以理解为唯一id，在partition内部严格递增</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>从一条消息的视角，看看为什么Kafka能支持这么高的吞吐</p><p>Producer发送Message到Broker，若等到发送成功再发下一条，效率是远远不够的。可以先对消息做一个Batch（批量处理），减少IO次数，加强发送能力。</p><p>此时会遇到消息量过大，带宽不够的问题。可以使用压缩算法来解决Snappy、<strong>ZSTD</strong>等压缩到本地磁盘。那么如何存储？</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><h4 id="消息文件结构"><a href="#消息文件结构" class="headerlink" title="消息文件结构"></a>消息文件结构</h4><p>Topic&#x2F;Partition&#x2F;Replica&#x2F;Segement&#x2F;(log | index | timeindex | … )</p><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><p>移动磁头找到对应磁道，磁盘转动，找到对应扇区，最后写入。寻道成本比较高，因此顺序写可以减少寻道所带来的时间成本。</p><p>顺序写：采用顺序写的的方式写入，以提高写入效率。 </p><h4 id="如何找到消息"><a href="#如何找到消息" class="headerlink" title="如何找到消息"></a>如何找到消息</h4><p>Consumer通过发送FetchRequest请求消息数据，Broker会将指定Offser处的消息，按照时间窗口和消息大小窗口发送给Consumer，寻找数据这个细节如何做到？</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Goland </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go进阶 - Gin基础使用及实战</title>
      <link href="/post/b4a026b3.html"/>
      <url>/post/b4a026b3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Gin介绍"><a href="#Gin介绍" class="headerlink" title="Gin介绍"></a>Gin介绍</h2><p><a href="https://gin-gonic.com/">Gin</a> 是一个用于Go语言（Golang）的Web框架，提供了快速、简洁的HTTP Web服务器以及路由、中间件等必要功能。本笔记介绍了使用Gin构建Web应用程序的基础知识。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>要使用Gin，首先需要进行安装。打开终端并运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><p>以下是一个示例代码，演示了基本的用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//创建一个服务</span></span><br><span class="line">ginServer := gin.Default()</span><br><span class="line"><span class="comment">//访问地址 处理请求</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">context.JSON(<span class="number">200</span>, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;hello world&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载静态页面</span></span><br><span class="line">ginServer.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>)</span><br><span class="line"><span class="comment">//渲染</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">context.HTML(http.StatusOK, <span class="string">&quot;index.html&quot;</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>: <span class="string">&quot;hahahhahahaha&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//接受前端传递过来的参数</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/user/info&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">userid := context.Query(<span class="string">&quot;userid&quot;</span>)</span><br><span class="line">username := context.Query(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;userid&quot;</span>:   userid,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/user/info/:userid/:username&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">userid := context.Param(<span class="string">&quot;userid&quot;</span>)</span><br><span class="line">username := context.Param(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;userid&quot;</span>:   userid,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//前端给后端传递Json</span></span><br><span class="line">ginServer.POST(<span class="string">&quot;/json&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">//Json在request.body中</span></span><br><span class="line">body, _ := context.GetRawData()</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 空接口 接受所有类型</span></span><br><span class="line">_ = json.Unmarshal(body, &amp;m)</span><br><span class="line"></span><br><span class="line">context.JSON(http.StatusOK, m)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Router</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">context.Redirect(<span class="number">301</span>, <span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义404页面</span></span><br><span class="line">ginServer.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">context.HTML(http.StatusNotFound, <span class="string">&quot;404.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//路由组</span></span><br><span class="line">userGroup := ginServer.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">userGroup.GET(<span class="string">&quot;/add&quot;</span>)</span><br><span class="line">userGroup.GET(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">orderGroup := ginServer.Group(<span class="string">&quot;/order&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">orderGroup.GET(<span class="string">&quot;/add&quot;</span>)</span><br><span class="line">orderGroup.GET(<span class="string">&quot;/delete&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器端口 默认为8080</span></span><br><span class="line">ginServer.Run(<span class="string">&quot;:8082&quot;</span>) <span class="comment">// 默认8080</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Gin-Gorm项目实战"><a href="#Gin-Gorm项目实战" class="headerlink" title="Gin Gorm项目实战"></a>Gin Gorm项目实战</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>提供了一系列功能，包括发布帖子、查询页面信息等。使用了 Go 语言进行开发，并采用了 MVC（Model-View-Controller）架构模式，以实现代码结构的清晰和模块化。  </p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul><li>controller：包含处理请求的控制器函数。  </li><li>models：包含与数据库交互的数据模型和数据访问对象。  </li><li>service：包含业务逻辑和服务流程的实现。  </li><li>router：包含路由初始化函数，用于定义和配置路由（组）等。  </li><li>main.go：应用程序的入口文件。</li></ul><h3 id="模型介绍"><a href="#模型介绍" class="headerlink" title="模型介绍"></a>模型介绍</h3><p>三个实体：主题（Topic）、帖子（Post）和用户（User）  </p><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><ul><li>一个主题可以包含多个帖子，每个帖子都对应唯一的一个主题。  </li><li>每个帖子都属于一个用户，即用户和帖子是一对一的关系。  </li><li>每个主题也属于一个用户，即用户和主题是一对一的关系。</li></ul><h3 id="0基础"><a href="#0基础" class="headerlink" title="0基础"></a>0基础</h3><h4 id="Dao？"><a href="#Dao？" class="headerlink" title="Dao？"></a>Dao？</h4><p>数据访问对象（DAO），封装了对数据的操作。  </p><ol><li>分离数据访问逻辑：UserDao的存在可以将数据访问逻辑与业务逻辑分离。这样，业务逻辑层不需要关心具体的数据访问细节，只需要调用UserDao提供的方法来获取或修改用户数据。这样可以提高代码的可维护性和可测试性。  </li><li>封装数据库操作：UserDao封装了对数据库的操作，包括查询、插入、更新等。这样，业务逻辑层不需要直接与数据库打交道，而是通过UserDao来进行数据库操作。这样可以降低业务逻辑层与数据库之间的耦合度，提高代码的灵活性和可扩展性。  </li><li>提供统一的接口：UserDao提供了一组统一的接口方法来操作用户数据。这样，无论是查询单个用户还是批量查询用户，业务逻辑层都可以通过调用UserDao的方法来完成。这样可以提高代码的一致性和可读性。</li></ol><h4 id="Flow？"><a href="#Flow？" class="headerlink" title="Flow？"></a>Flow？</h4><p>工作流（FLOW），封装了处理操作的顺序和流程。  </p><ol><li>控制数据操作流程：使用 Flow 可以更好地控制数据操作的流程和顺序。通过定义工作流，可以规定数据操作的先后顺序、条件判断和错误处理等。这样可以确保数据操作按照预期的流程执行，提高了代码的可靠性和稳定性。  </li><li>简化复杂操作：对于复杂的数据操作，Flow 可以将其分解为一系列简单的步骤。每个步骤可以由独立的函数或方法来实现，使得代码更加模块化和可维护。通过定义工作流，可以按照特定的顺序执行这些步骤，并在需要时进行条件判断或错误处理。  </li><li>提高代码可读性：使用 Flow 可以使代码更具可读性和可理解性。通过定义工作流，可以清晰地展示数据操作的流程和逻辑。这样，其他开发人员可以更轻松地理解代码的意图和执行顺序，从而提高团队协作和代码维护的效率。</li></ol><h4 id="sync-Once？"><a href="#sync-Once？" class="headerlink" title="sync.Once？"></a>sync.Once？</h4><p>以UserDao为例，使用了 sync.Once 来确保 UserDao 的实例只创建一次。sync.Once 是 Go 语言标准库中的一个同步原语，它提供了一种安全且高效的方式来执行只需执行一次的操作。  </p><p>在这种情况下，使用 sync.Once 的目的是确保 UserDao 的实例化操作只会执行一次，即使在并发环境下也能保证。这样可以避免多个 goroutine 同时执行实例化操作，造成重复创建实例或其他竞态条件的问题。</p><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/LXJ0000/CT">CT</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go进阶 - GRPC使用</title>
      <link href="/post/1baa82a4.html"/>
      <url>/post/1baa82a4.html</url>
      
        <content type="html"><![CDATA[<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>(Remootee Procceduure Calls) 远程过程调用   </p><p>是一种协议，用来屏蔽分布式计算机中的各种调用细节，使得可以像是本地调用一样直接调用一个远程函数</p><h3 id="为什么需要RPC"><a href="#为什么需要RPC" class="headerlink" title="为什么需要RPC?"></a>为什么需要RPC?</h3><p>一般的：</p><p>客户端 与 服务端 沟通的过程</p><ol><li>客户端发送数据（以字节流的方式）</li><li>服务端接受并解析。把结果返回给客户</li></ol><p>RPC：</p><ol><li>RPC就是将上述过程封装，使其操作更加优化</li><li>使用一些大家都认可的协议，使其规范化</li><li>做成一些框架，直接或间接产生利益</li></ol><h2 id="GRPC"><a href="#GRPC" class="headerlink" title="GRPC"></a>GRPC</h2><p>GRPC就是一个高性能的、开源的、通用的RPC框架</p><p><a href="https://grpc.io/">GRPC官网</a>  </p><p><a href="https://doc.oschina.net/grpc">中文文档</a></p><p>grpc使用了Protocol Buffss.这是谷歌开源的一套成熟的数据结构序列化机制。</p><ul><li>序列化：把数据结构或对象转成二进制串的过程 </li><li>反序列化：将在序列化过程中所产生的二进制串转成数据结构或对象的过程</li></ul><h3 id="安装Protobuf"><a href="#安装Protobuf" class="headerlink" title="安装Protobuf"></a>安装Protobuf</h3><h4 id="1-安装protocol-buffers"><a href="#1-安装protocol-buffers" class="headerlink" title="1. 安装protocol buffers"></a>1. 安装protocol buffers</h4><p><a href="https://github.com/protocolbuffers/protobuf/releases">下载地址</a></p><p>下载win安装包、解压到本地、添加环境变量。</p><p>测试：cmd输入protoc</p><h4 id="2-安装gRPC核心库"><a href="#2-安装gRPC核心库" class="headerlink" title="2. 安装gRPC核心库"></a>2. 安装gRPC核心库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u google.goland.org/grpc</span><br></pre></td></tr></table></figure><h4 id="3-安装go-protocol-buffers的插件protoc-gen-go"><a href="#3-安装go-protocol-buffers的插件protoc-gen-go" class="headerlink" title="3. 安装go protocol buffers的插件protoc-gen-go"></a>3. 安装go protocol buffers的插件protoc-gen-go</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest`</span><br></pre></td></tr></table></figure><h3 id="Proto文件"><a href="#Proto文件" class="headerlink" title="Proto文件"></a>Proto文件</h3><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. hello.proto</span><br><span class="line">protoc --go-grpc_out=. hello.proto</span><br></pre></td></tr></table></figure><h4 id="文件编写"><a href="#文件编写" class="headerlink" title="文件编写"></a>文件编写</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option go_package = &quot;.;service&quot;;</span><br><span class="line"></span><br><span class="line">service SayHello&#123;</span><br><span class="line">  rpc SayHello(HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloRequest&#123;</span><br><span class="line">  string requestName = 1;</span><br><span class="line">&#125;</span><br><span class="line">message HelloResponse&#123;</span><br><span class="line">  string responseMsg = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>message<br>数据格式的定义，类似结构体</li><li>字段规则<ul><li>required 必填字段 不设置会导致编码异常 protobuf3被删去</li><li>optional 可选字段 默认</li><li>repeated 可重复字段 go中会被定义为切片</li></ul></li><li>消息号<br>在消息体的定义中，每个字段都必须有一个唯一的标识号</li></ol><p>消息体是可以嵌套使用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">message PersonInfo&#123;</span><br><span class="line">    message Person&#123;</span><br><span class="line">        string name = 1;</span><br><span class="line">        int32 height = 2;</span><br><span class="line">        repeated int32 weight = 3;</span><br><span class="line">    &#125;</span><br><span class="line">    repeated Person info = 1;</span><br><span class="line">&#125;</span><br><span class="line">message PersonMessage&#123;</span><br><span class="line">    PersonInfo.Person info = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>服务定义<br>相当于函数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service SercjService&#123;</span><br><span class="line">    # rpc 服务函数名（参数） 返回 （返回参数）&#123;&#125;</span><br><span class="line">    rpc Search(SearchResquest) return (SearchResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端编写"><a href="#服务端编写" class="headerlink" title="服务端编写"></a>服务端编写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line">pb <span class="string">&quot;douyin/server/proto&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">pb.UnimplementedSayHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.HelloResponse&#123;ResponseMsg: <span class="string">&quot;Hello&quot;</span> + req.RequestName&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//开启端口</span></span><br><span class="line">listen, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9090&quot;</span>)</span><br><span class="line"><span class="comment">//创建GRPC服务</span></span><br><span class="line">grpcServer := grpc.NewServer()</span><br><span class="line"><span class="comment">//再grpc服务端注册自己编写的服务</span></span><br><span class="line">pb.RegisterSayHelloServer(grpcServer, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">_ = grpcServer.Serve(listen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="客户端编写"><a href="#客户端编写" class="headerlink" title="客户端编写"></a>客户端编写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line">pb <span class="string">&quot;douyin/server/proto&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//连接到server端</span></span><br><span class="line">    <span class="comment">// 此处禁用安全认证</span></span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;127.0.0.1:9090&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line">client := pb.NewSayHelloClient(conn)</span><br><span class="line"><span class="comment">//执行rpc调用（这个方法是在服务端实现并返回结果</span></span><br><span class="line">resp, _ := client.SayHello(context.Background(), &amp;pb.HelloRequest&#123;RequestName: <span class="string">&quot;LXJ &quot;</span>&#125;)</span><br><span class="line">fmt.Println(resp.GetResponseMsg())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="认证、安全传输"><a href="#认证、安全传输" class="headerlink" title="认证、安全传输"></a>认证、安全传输</h3><p>默认使用protobuf作为传输协议 当然也可以自定义其他协议。</p><h4 id="SSL-TLS认证方式"><a href="#SSL-TLS认证方式" class="headerlink" title="SSL&#x2F;TLS认证方式"></a>SSL&#x2F;TLS认证方式</h4><h5 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h5><p><a href="https://slproweb.com/products/Win32OpenSSL.html">安装包下载</a></p><p>配置环境变量</p><p>测试<code>openssl</code></p><h5 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 1、生成私钥</span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"></span><br><span class="line"># 2、生成证书</span><br><span class="line">openssl req -new -x509 -key server.key -out server.crt -days 36500</span><br><span class="line"></span><br><span class="line"># 3、生成csr</span><br><span class="line">openssl req -new -key server.key -out server.csr</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 复制bin中的openssl.cnf到key</span><br><span class="line">2. 找到[CA_default] 取消注释 copy_extensions = copy</span><br><span class="line">3. 找到[req] 取消注释 req_extensions = v3_req</span><br><span class="line">4. 找到[v3_req]  添加 subjectAltName = @alt_names</span><br><span class="line">5. 添加新的标签[alt_names] 和 标签字段 DNS.1 = *.Gangnam.com</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 生成证书私钥test.key</span><br><span class="line">openssl genpkey -algorithm RSA -out test.key</span><br><span class="line"></span><br><span class="line"># 通过私钥test.key生成证书请求文件test.csr</span><br><span class="line">openssl req -new -nodes -key test.key -out test.csr -days 3650 -subj &quot;/C=cn/OU=myorg/O=mycomp/CN=myname&quot; -config ./openssl.cfg -extensions v3_req</span><br><span class="line"></span><br><span class="line"># 生成SAN证书 pem</span><br><span class="line">openssl x509 -req -days 365 -in test.csr -out test.pem -CA server.crt -CAkey server.key -CAcreateserial -extfile ./openssl.cfg -extensions v3_req</span><br></pre></td></tr></table></figure><h5 id="server端代码"><a href="#server端代码" class="headerlink" title="server端代码"></a>server端代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line">pb <span class="string">&quot;douyin/server/proto&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/credentials&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">pb.UnimplementedSayHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.HelloResponse&#123;ResponseMsg: <span class="string">&quot;Hello&quot;</span> + req.RequestName&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//TLS认证</span></span><br><span class="line">creds, _ := credentials.NewServerTLSFromFile(<span class="string">&quot;D:\\GoProjects\\douyin\\key\\test.pem&quot;</span>,</span><br><span class="line"><span class="string">&quot;D:\\GoProjects\\douyin\\key\\test.key&quot;</span>)</span><br><span class="line"><span class="comment">//开启端口</span></span><br><span class="line">listen, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9090&quot;</span>)</span><br><span class="line"><span class="comment">//创建GRPC服务</span></span><br><span class="line">grpcServer := grpc.NewServer(grpc.Creds(creds))</span><br><span class="line"><span class="comment">//再grpc服务端注册自己编写的服务</span></span><br><span class="line">pb.RegisterSayHelloServer(grpcServer, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">_ = grpcServer.Serve(listen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="client端代码"><a href="#client端代码" class="headerlink" title="client端代码"></a>client端代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line">pb <span class="string">&quot;douyin/server/proto&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/credentials&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, _ := credentials.NewClientTLSFromFile(<span class="string">&quot;D:\\GoProjects\\douyin\\key\\test.pem&quot;</span>,</span><br><span class="line"><span class="string">&quot;*.Gangnam.com&quot;</span>)</span><br><span class="line"><span class="comment">//连接到server端</span></span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;127.0.0.1:9090&quot;</span>, grpc.WithTransportCredentials(file))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line">client := pb.NewSayHelloClient(conn)</span><br><span class="line"><span class="comment">//执行rpc调用（这个方法是在服务端实现并返回结果</span></span><br><span class="line">resp, _ := client.SayHello(context.Background(), &amp;pb.HelloRequest&#123;RequestName: <span class="string">&quot;LXJ &quot;</span>&#125;)</span><br><span class="line">fmt.Println(resp.GetResponseMsg())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Token认证方式"><a href="#Token认证方式" class="headerlink" title="Token认证方式"></a>Token认证方式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PerRPCCredentials <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// GetRequestMetadata gets the current request metadata, refreshing tokens</span></span><br><span class="line"><span class="comment">// if required. This should be called by the transport layer on each</span></span><br><span class="line"><span class="comment">// request, and the data should be populated in headers or other</span></span><br><span class="line"><span class="comment">// context. If a status code is returned, it will be used as the status for</span></span><br><span class="line"><span class="comment">// the RPC (restricted to an allowable set of codes as defined by gRFC</span></span><br><span class="line"><span class="comment">// A54). uri is the URI of the entry point for the request.  When supported</span></span><br><span class="line"><span class="comment">// by the underlying implementation, ctx can be used for timeout and</span></span><br><span class="line"><span class="comment">// cancellation. Additionally, RequestInfo data will be available via ctx</span></span><br><span class="line"><span class="comment">// to this call.  TODO(zhaoq): Define the set of the qualified keys instead</span></span><br><span class="line"><span class="comment">// of leaving it as an arbitrary string.</span></span><br><span class="line">GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// RequireTransportSecurity indicates whether the credentials requires</span></span><br><span class="line"><span class="comment">// transport security.</span></span><br><span class="line">RequireTransportSecurity() <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个方法的作用是获取元数据信息，也就是客户端提供(key valued)对, context用于控制超时和取消，uri是请求入口处的uri</p><p>第二个方法的作用是是否需要基于TLS认证进行安全传输，如果返回值是true，则必须加上TLS验证，false则不需要</p><h5 id="Client端代码"><a href="#Client端代码" class="headerlink" title="Client端代码"></a>Client端代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line">pb <span class="string">&quot;douyin/server/proto&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ClientTokenAuth <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ClientTokenAuth)</span></span> GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;appId&quot;</span>:  <span class="string">&quot;lxj&quot;</span>,</span><br><span class="line"><span class="string">&quot;appKey&quot;</span>: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c ClientTokenAuth)</span></span> RequireTransportSecurity() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 不开启安全认证</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//file, _ := credentials.NewClientTLSFromFile(&quot;D:\\GoProjects\\douyin\\key\\test.pem&quot;,</span></span><br><span class="line"><span class="comment">//&quot;*.Gangnam.com&quot;)</span></span><br><span class="line"><span class="comment">//连接到server端</span></span><br><span class="line"><span class="keyword">var</span> opts []grpc.DialOption</span><br><span class="line">opts = <span class="built_in">append</span>(opts, grpc.WithTransportCredentials(insecure.NewCredentials())) <span class="comment">// 无安全认证 上面是false</span></span><br><span class="line">opts = <span class="built_in">append</span>(opts, grpc.WithPerRPCCredentials(<span class="built_in">new</span>(ClientTokenAuth)))</span><br><span class="line"></span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;127.0.0.1:9090&quot;</span>, opts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line">client := pb.NewSayHelloClient(conn)</span><br><span class="line"><span class="comment">//执行rpc调用（这个方法是在服务端实现并返回结果</span></span><br><span class="line">resp, _ := client.SayHello(context.Background(), &amp;pb.HelloRequest&#123;RequestName: <span class="string">&quot;LXJ &quot;</span>&#125;)</span><br><span class="line">fmt.Println(resp.GetResponseMsg())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Server端代码"><a href="#Server端代码" class="headerlink" title="Server端代码"></a>Server端代码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line">pb <span class="string">&quot;douyin/server/proto&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc/metadata&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">pb.UnimplementedSayHelloServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello 业务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, req *pb.HelloRequest) (*pb.HelloResponse, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">//获取元数据信息</span></span><br><span class="line">md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;未传输Token&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> appId <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> appKey <span class="type">string</span></span><br><span class="line"><span class="keyword">if</span> v, ok := md[<span class="string">&quot;appid&quot;</span>]; ok &#123;</span><br><span class="line">appId = v[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v, ok := md[<span class="string">&quot;appkey&quot;</span>]; ok &#123;</span><br><span class="line">appKey = v[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验</span></span><br><span class="line"><span class="keyword">if</span> appId != <span class="string">&quot;lxj&quot;</span> || appKey != <span class="string">&quot;123&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;Token 错误&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello &quot;</span> + req.RequestName)</span><br><span class="line"><span class="keyword">return</span> &amp;pb.HelloResponse&#123;ResponseMsg: <span class="string">&quot;Hello&quot;</span> + req.RequestName&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//TLS认证</span></span><br><span class="line"><span class="comment">//creds, _ := credentials.NewServerTLSFromFile(&quot;D:\\GoProjects\\douyin\\key\\test.pem&quot;,</span></span><br><span class="line"><span class="comment">//&quot;D:\\GoProjects\\douyin\\key\\test.key&quot;)</span></span><br><span class="line"><span class="comment">//开启端口</span></span><br><span class="line">listen, _ := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9090&quot;</span>)</span><br><span class="line"><span class="comment">//创建GRPC服务</span></span><br><span class="line">grpcServer := grpc.NewServer(grpc.Creds(insecure.NewCredentials()))</span><br><span class="line"><span class="comment">//再grpc服务端注册自己编写的服务</span></span><br><span class="line">pb.RegisterSayHelloServer(grpcServer, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动服务</span></span><br><span class="line">_ = grpcServer.Serve(listen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> GRPC </tag>
            
            <tag> RPC </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go进阶 - Xorm以及Gorm使用</title>
      <link href="/post/1380be4c.html"/>
      <url>/post/1380be4c.html</url>
      
        <content type="html"><![CDATA[<p>原理咱就略过<del>我知道很重要</del>，奔着去实战学习</p><h1 id="XORM"><a href="#XORM" class="headerlink" title="XORM"></a>XORM</h1><p>xorm是一个简单而强大的Go语言ORM库. 通过它可以使数据库操作非常简便。xorm的目标并不是让你完全不去学习SQL，我们认为SQL并不会为ORM所替代，但是ORM将可以解决绝大部分的简单SQL需求。xorm支持两种风格的混用。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>支持Struct和数据库表之间的灵活映射，并支持自动同步</li><li>事务支持</li><li>同时支持原始SQL语句和ORM操作的混合执行</li><li>使用连写来简化调用</li><li>支持使用Id, In, Where, Limit, Join, Having, Table, SQL, Cols等函数和结构体等方式作为条件</li><li>支持级联加载Struct</li><li>Schema支持（仅Postgres）</li><li>支持缓存</li><li>支持根据数据库自动生成xorm的结构体</li><li>支持记录版本（即乐观锁）</li><li>内置SQL Builder支持</li><li>通过EngineGroup支持读写分离和负载均衡</li></ul><h2 id="参考资料以及学习手册-常用"><a href="#参考资料以及学习手册-常用" class="headerlink" title="参考资料以及学习手册 常用~"></a>参考资料以及学习手册 常用~</h2><p><a href="https://xorm.io/zh/">xorm</a><br><a href="https://gitea.com/xorm/xorm/src/branch/master/README_CN.md">API</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>go get xorm.io/xorm</code></p><h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>创建一个连接到 MySQL 数据库的引擎，首先定义一些变量来存储数据库连接所需的信息。</p><p><code>xorm.NewEngine(&quot;mysql&quot;, dataSourceName)</code> 用于创建一个 xorm 引擎，该引擎将使用 MySQL 驱动连接到数据库</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    username  <span class="type">string</span> = <span class="string">&quot;root&quot;</span></span><br><span class="line">    password  <span class="type">string</span> = <span class="string">&quot;root1234&quot;</span></span><br><span class="line">    ipAddress <span class="type">string</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    port      <span class="type">int</span>    = <span class="number">3306</span></span><br><span class="line">    dbName    <span class="type">string</span> = <span class="string">&quot;go_test&quot;</span></span><br><span class="line">    charset   <span class="type">string</span> = <span class="string">&quot;utf8mb4&quot;</span></span><br><span class="line">)</span><br><span class="line">dataSourceName := fmt.Sprintf(<span class="string">&quot;%s:%s@tcp(%s:%d)/%s?charset=%s&quot;</span>, username, password, ipAddress, port, dbName, charset)</span><br><span class="line"><span class="comment">// xorm.NewEngine()</span></span><br><span class="line">engine, err := xorm.NewEngine(<span class="string">&quot;mysql&quot;</span>, dataSourceName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;数据库连接失败&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Exec-执行一个SQL语句"><a href="#Exec-执行一个SQL语句" class="headerlink" title="Exec 执行一个SQL语句"></a>Exec 执行一个SQL语句</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">affected, err := engine.Exec(<span class="string">&quot;update user set age = ? where name = ?&quot;</span>, age, name)</span><br></pre></td></tr></table></figure><p>当然也可以不用传参数 直接写在sql代码中</p><p><code>affected</code> 是一个整数，表示受影响的行数，即更新操作影响的数据库记录数。</p><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><p>定义结构体，这里以User为例，后面的字段自行参考文档~</p><p><code>engine.Sync(new(User))</code> 用于将结构体 <code>User</code> 的定义与数据库表进行同步。这意味着它将根据结构体的定义自动创建或更新对应的数据库表结构，以确保它与结构体的定义保持一致。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id      <span class="type">int64</span></span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    Age     <span class="type">int</span></span><br><span class="line">    Passwd  <span class="type">string</span>    <span class="string">`xorm:&quot;varchar(200)&quot;`</span></span><br><span class="line">    Created time.Time <span class="string">`xorm:&quot;created&quot;`</span></span><br><span class="line">    Updated time.Time <span class="string">`xorm:&quot;updated&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = engine.Sync(<span class="built_in">new</span>(User))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;表结构同步失败&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>使用 <code>engine.Insert</code> 方法将结构体实例 <code>user</code> 插入到数据库中。<code>&amp;user</code> 使用指针传递结构体实例的地址，以便 <code>engine.Insert</code> 方法可以修改结构体的字段值。<code>n</code> 是插入操作受影响的行数，用于判断插入是否成功。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user := User&#123;Id: <span class="number">1</span>, Name: <span class="string">&quot;huai&quot;</span>, Age: <span class="number">18</span>, Passwd: <span class="string">&quot;root&quot;</span>&#125;</span><br><span class="line">n, _ := engine.Insert(&amp;user)</span><br><span class="line"><span class="keyword">if</span> n &gt;= <span class="number">1</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;数据插入成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user1 := User&#123;Id: <span class="number">2</span>, Name: <span class="string">&quot;huai&quot;</span>, Age: <span class="number">18</span>, Passwd: <span class="string">&quot;root&quot;</span>&#125;</span><br><span class="line">user2 := User&#123;Id: <span class="number">3</span>, Name: <span class="string">&quot;huai&quot;</span>, Age: <span class="number">18</span>, Passwd: <span class="string">&quot;root&quot;</span>&#125;</span><br><span class="line">n, _ := engine.Insert(&amp;user1, &amp;user2)</span><br><span class="line"><span class="keyword">if</span> n &gt;= <span class="number">1</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>insert</code>还可以插入<code>users[]</code>等…… 查阅API文档</p><h3 id="删、改"><a href="#删、改" class="headerlink" title="删、改"></a>删、改</h3><p>改、删哪一个数据就写哪个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user = User&#123;Name: <span class="string">&quot;huai&quot;</span>&#125;</span><br><span class="line">n, _ = engine.ID(<span class="number">2</span>).Delete(&amp;user)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user = User&#123;Name: <span class="string">&quot;XJ&quot;</span>&#125;</span><br><span class="line">n, _ = engine.ID(<span class="number">1</span>).Update(&amp;user)</span><br></pre></td></tr></table></figure><p>其他用法可查阅API文档</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul><li>Query</li><li><code>Get</code> 查询单条记录</li><li>Find查询多条记录</li><li>Count 获取记录条数</li><li>Iterater Rows根据条件遍历数据</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res1, err := engine.Query(<span class="string">&quot;select * from user&quot;</span>)  <span class="comment">//切片信息</span></span><br><span class="line">res2, err := engine.QueryString(<span class="string">&quot;select * from user&quot;</span>)</span><br><span class="line">res3, err := engine.QueryInterface(<span class="string">&quot;select * from user&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Get</span></span><br><span class="line">user := User&#123;Name: <span class="string">&quot;huai&quot;</span>&#125;</span><br><span class="line"><span class="comment">// ?号查询避免SQL注入</span></span><br><span class="line">engine.Where(<span class="string">&quot;name=?&quot;</span>, user.Name).Desc(<span class="string">&quot;id&quot;</span>).Get(&amp;user)</span><br><span class="line">fmt.Println(user)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> passwd <span class="type">string</span></span><br><span class="line">engine.Table(&amp;user).Where(<span class="string">&quot;id=5&quot;</span>).Cols(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;passwd&quot;</span>).Get(&amp;name, &amp;passwd)</span><br><span class="line">fmt.Println(name, passwd)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find</span></span><br><span class="line"><span class="keyword">var</span> users []User</span><br><span class="line">engine.Where(<span class="string">&quot;passwd=?&quot;</span>, <span class="string">&quot;root&quot;</span>).And(<span class="string">&quot;age=?&quot;</span>, <span class="number">18</span>).Limit(<span class="number">3</span>, <span class="number">0</span>).Find(&amp;users)</span><br><span class="line">fmt.Println(users)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Count 查询多少条数据</span></span><br><span class="line">user := User&#123;passwd: <span class="string">&quot;root&quot;</span>&#125;</span><br><span class="line">cnt, err := engine.Count(&amp;user)</span><br><span class="line">fmt.Println(cnt)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">err := engine.Iterate(&amp;User&#123;Name:name&#125;, <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>, bean <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    user := bean.(*User)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM user</span></span><br><span class="line"></span><br><span class="line">err := engine.BufferSize(<span class="number">100</span>).Iterate(&amp;User&#123;Name:name&#125;, <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>, bean <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    user := bean.(*User)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM user Limit 0, 100</span></span><br><span class="line"><span class="comment">// SELECT * FROM user Limit 101, 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rows 的用法类似 sql.Rows</span></span><br><span class="line"></span><br><span class="line">rows, err := engine.Rows(&amp;User&#123;Name:name&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM user</span></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line">bean := <span class="built_in">new</span>(Struct)</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    err = rows.Scan(bean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><a href="https://www.bilibili.com/video/BV17P4y1R7Ji/?p=6&spm_id_from=pageDriver&vd_source=2cb41caee9551fbf13c606149026e31c">事务</a></p><h1 id="GORM"><a href="#GORM" class="headerlink" title="GORM"></a>GORM</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性<a href="https://gorm.io/zh_CN/docs/index.html#%E7%89%B9%E6%80%A7"></a></h2><ul><li>全功能 ORM</li><li>关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)</li><li>Create，Save，Update，Delete，Find 中钩子方法</li><li>支持 <code>Preload</code>、<code>Joins</code> 的预加载</li><li>事务，嵌套事务，Save Point，Rollback To Saved Point</li><li>Context、预编译模式、DryRun 模式</li><li>批量插入，FindInBatches，Find&#x2F;Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD</li><li>SQL 构建器，Upsert，数据库锁，Optimizer&#x2F;Index&#x2F;Comment Hint，命名参数，子查询</li><li>复合主键，索引，约束</li><li>Auto Migration</li><li>自定义 Logger</li><li>灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li>每个特性都经过了测试的重重考验</li><li>开发者友好</li></ul><h2 id="常用资料"><a href="#常用资料" class="headerlink" title="常用资料"></a>常用资料</h2><p><a href="https://gorm.io/zh_CN/docs/index.html">Gorm</a></p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get -u gorm.io/gorm</span><br><span class="line">go get -u gorm.io/driver/sqlite // sqline安装</span><br><span class="line">go get -u gorm.io/driver/mysql  // mysql安装</span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>定义gorm model</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span>&#123;</span><br><span class="line">    ID <span class="type">uint</span> <span class="string">`gorm:&quot;primarykey&quot;`</span></span><br><span class="line">    Code <span class="type">string</span> <span class="string">`gorm:&quot;colimn:code&quot;`</span></span><br><span class="line">    Price <span class="type">uint</span> <span class="string">`gorm:&quot;default:0&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为model定义表名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Product)</span></span> TableName() <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`product`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 连接数据库</span></span><br><span class="line">    db, err := gorm.Open(mysql.Open(dsn, &amp;gorm.Config&#123;&#125;))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;failed to connect database&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建数据</span></span><br><span class="line">    db.Create($Product&#123;Code:<span class="string">&quot;D42&quot;</span>, Price:<span class="number">100</span>&#125;)</span><br><span class="line">    <span class="comment">// 查询数据</span></span><br><span class="line">    <span class="keyword">var</span> product Product</span><br><span class="line">    db.First(&amp;product, <span class="number">1</span>) <span class="comment">// 查询id = 1</span></span><br><span class="line">    db.First(&amp;product, <span class="string">&quot;code = ?&quot;</span>, <span class="number">200</span>)</span><br><span class="line">    <span class="comment">// 更新数据</span></span><br><span class="line">        <span class="comment">// 将product的price更改为200</span></span><br><span class="line">    db.Model(&amp;product).Update(<span class="string">&quot;Price&quot;</span>, <span class="number">200</span>)</span><br><span class="line">        <span class="comment">// 更改多个字段</span></span><br><span class="line">    db.Model(&amp;product).Update(Product&#123;Price:<span class="number">200</span>, Code:<span class="string">&quot;F42&quot;</span>&#125;)</span><br><span class="line">    db.Model(&amp;product).Updata(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Price&quot;</span>:<span class="number">200</span>, <span class="string">&quot;Code&quot;</span>:<span class="string">&quot;F42&quot;</span>&#125;)</span><br><span class="line">    <span class="comment">// 删除数据</span></span><br><span class="line">    db.Delete(&amp;product, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First 查询第一条数据 （主键升序）查询不到返回ErrRecordNotFound</span></span><br><span class="line"><span class="comment">// Find 查询一组数据 查询不到返回空数组 不会返回错误</span></span><br><span class="line">users := <span class="built_in">make</span>([]*User, <span class="number">0</span>)</span><br><span class="line">res := db.Where(<span class="string">&quot;age &gt; ?&quot;</span>, <span class="number">10</span>).Find(&amp;users)</span><br><span class="line">res.RowsAffected <span class="comment">//找到的记录数</span></span><br><span class="line">res.Error <span class="comment">// </span></span><br></pre></td></tr></table></figure><p>删除数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 物理删除</span></span><br><span class="line">db.Delete</span><br><span class="line"><span class="comment">// 软删除</span></span><br><span class="line"><span class="comment">// 添加表字段 Deleteed gorm.DeleteAt 即可实现软删除</span></span><br><span class="line"><span class="comment">// 使用Unscoped查询被软删的数据</span></span><br></pre></td></tr></table></figure><h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><p>Gorm提供了Begin、Commit、Rollback方法用于使用事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tx := db.Begin() <span class="comment">// 开启事务</span></span><br><span class="line"><span class="keyword">if</span> err = tx.Create(&amp;User&#123;Name:<span class="string">&quot;name&quot;</span>&#125;).Error; err != <span class="literal">nil</span>&#123;</span><br><span class="line">    tx.Rollback() <span class="comment">// 回滚事务 </span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = tx.Create(&amp;User&#123;Name:<span class="string">&quot;name1&quot;</span>&#125;).Error; err != <span class="literal">nil</span>&#123;</span><br><span class="line">    tx.Rollback()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">tx.Commit()</span><br></pre></td></tr></table></figure><p>Gorm提供了Transaction方法用于自动提交事务，避免用户漏泄Commit Rollback</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err = db.Transaction(<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span></span> <span class="type">error</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> err = tx.Create(&amp;User&#123;Name:<span class="string">&quot;name&quot;</span>&#125;).Error; err != <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = tx.Create(&amp;User&#123;Name:<span class="string">&quot;name&quot;</span>&#125;).Error; err != <span class="literal">nil</span>&#123;</span><br><span class="line">        tx.Rollback() <span class="comment">// ??????</span></span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;); err != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><p>Hook是在创建、查询、删除、更新等操作之前、之后自动调用的函数<br>如果任何Hook返回错误，GORM将停止后续的操作并回滚事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> BeforeCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> u.Age &lt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;can&#x27;t save invalid data&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span></span> AfterCreate(tx *gorm.DB) (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> tx.Create(&amp;Email&#123;ID:u.ID, Email:u.Name + <span class="string">&quot;@qq.com&quot;</span>, &#125;).Error</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="性能提高"><a href="#性能提高" class="headerlink" title="性能提高"></a>性能提高</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&amp;gorm.Config&#123;</span><br><span class="line">    <span class="comment">// 禁用默认事务</span></span><br><span class="line">    <span class="comment">// 对于写操作（创建、更新、删除），为了确保数据的完整性，GORM 会将它们封装在一个事务里。但这会降低性能，你可以在初始化时禁用这种方式</span></span><br><span class="line">    SkipDefaultTransaction: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 缓存预编译语句</span></span><br><span class="line">    <span class="comment">// 执行任何 SQL 时都创建并缓存预编译语句，可以提高后续的调用速度</span></span><br><span class="line">    PrepareStmt: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Gorm </tag>
            
            <tag> Xorm </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言进阶</title>
      <link href="/post/e3ce3957.html"/>
      <url>/post/e3ce3957.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言进阶"><a href="#Go语言进阶" class="headerlink" title="Go语言进阶"></a>Go语言进阶</h1><p>Go充分发挥多核优势，高效运行</p><h2 id="协程-Goroutine"><a href="#协程-Goroutine" class="headerlink" title="协程 Goroutine"></a>协程 Goroutine</h2><p>协程：用户态，轻量级线程<br>线程：内核态，线程跑多个协程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;hello goroutine : &quot;</span> + fmt.Sprint(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloGoRountine</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">hello(j)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second) <span class="comment">// 阻塞 保证子协程完成之前主线程不退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSP-协程间通信"><a href="#CSP-协程间通信" class="headerlink" title="CSP 协程间通信"></a>CSP 协程间通信</h2><p>提倡通过<strong>通信共享内存</strong>而不是通过共享内存而实现通信（后者是互斥访问临界资源实现</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><code>make(chan 元素类型, [缓冲大小])</code></p><ul><li>无缓冲通道 又称为同步通道</li><li>有缓冲通道 存在缓冲大小</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CalSquare</span><span class="params">()</span></span> &#123;</span><br><span class="line">src := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">dest := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">// 不会因为消费者的消费速度问题影响生产者的执行效率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// A子协程发送 0 ~ 9</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(src)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">src &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// B子协程计算输入数字的平方</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(dest)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> src &#123;</span><br><span class="line">dest &lt;- i * i</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dest &#123; <span class="comment">// 主协程输出最后的平方数</span></span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并发安全-Lock"><a href="#并发安全-Lock" class="headerlink" title="并发安全 Lock"></a>并发安全 Lock</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">x    <span class="type">int64</span></span><br><span class="line">lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addWithLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++ &#123;</span><br><span class="line">lock.Lock() </span><br><span class="line">x += <span class="number">1</span></span><br><span class="line">lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addWithoutLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++ &#123;</span><br><span class="line">x += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">()</span></span> &#123;</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> addWithoutLock()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="built_in">println</span>(x)</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> addWithLock()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="built_in">println</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>目的：优化<code>time.sleep</code><br><code>Add(delta int) Done() Wait()  </code><br><strong>计数器</strong><br>开启协程<code>+1</code>; 执行结束<code>-1</code>; 主协程阻塞直到计数器为<code>0</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ManyGoWait</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">hello(j)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go依赖管理"><a href="#Go依赖管理" class="headerlink" title="Go依赖管理"></a>Go依赖管理</h2><p>演进：<code>GOPATH -&gt; GO Vendir -&gt; Go Module</code><br>目的：</p><ul><li>不同环境（项目）依赖的版本不同</li><li>控制依赖库的版本</li></ul><h2 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h2><p>默认拉取最新版本的提交</p><ul><li>@none <code>删除依赖</code></li><li>@1.1.2 <code>拉取特定版本</code></li><li>@23sdf <code>拉取commit提交</code></li><li>master <code>分支最新的commit</code></li></ul><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h2><p>init 初始化，创建go.mod文件<br>download 下载模块到本地缓存<br>tidy 增加需要的依赖，删除不需要的依赖</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>回归测试、集成测试、单元测试</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>测试文件名为原文件末尾换成_test.go<br>print.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HelloTom</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Tom&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>print_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line"><span class="comment">// 导入包报错 如下解决</span></span><br><span class="line"><span class="comment">// settings -&gt; Go -&gt; GoModule -&gt; Eable Go modules intergration</span></span><br><span class="line"><span class="comment">// go mod init mod&#x27;name</span></span><br><span class="line"><span class="comment">// go get &quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHelloTom</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">output := HelloTom()</span><br><span class="line">expectOutput := <span class="string">&quot;Tom&quot;</span></span><br><span class="line">assert.Equal(t, expectOutput, output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个文件同时选择后运行即可得到结果</p><h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><p><code>go test judge.go judge_test.go --cover</code>查看覆盖率</p><h2 id="Mock测试"><a href="#Mock测试" class="headerlink" title="Mock测试"></a>Mock测试</h2><p><a href="github.com/bouk/monkey">github.com&#x2F;bouk&#x2F;monkey</a></p><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p><a href="https://pkg.go.dev/testing#hdr-Benchmarks">pkg.go.dev&#x2F;testing#hdr…</a></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><code>any</code>、<code>comparable</code></p><ul><li>any：表示go里面所有的内置基本类型 等价于<code>interface&#123;&#125;</code></li><li>comparable：表示go里面所有内置的可比较类型<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str_arr := []<span class="type">string</span>&#123;<span class="string">&quot;HHH&quot;</span>, <span class="string">&quot;ZZZ&quot;</span>, <span class="string">&quot;UUU&quot;</span>&#125;</span><br><span class="line">int_arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">printArray(str_arr)</span><br><span class="line">printArray(int_arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func printArray[T string | int | float64](arr []T) &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArray</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(arr []T)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> arr &#123;</span><br><span class="line"><span class="built_in">println</span>(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>概念：超文本传输协议（<code>Hypertext Transfer Protocol</code>）<br>协议：需要明确边界、能够携带信息<br>协议包括：请求行、请求头、请求体、响应行、响应头、响应体  </p><h3 id="HTTP框架的设计与实现"><a href="#HTTP框架的设计与实现" class="headerlink" title="HTTP框架的设计与实现"></a>HTTP框架的设计与实现</h3><ul><li>应用层设计：提供合理的<code>API</code></li><li>中间件设计：日志记录、性能统计、安全控制、事务处理、异常处理</li><li>路由设计：为<code>URL</code>匹配对应的处理函数（<code>Handlers</code>）</li><li>协议层：抽象出合适的接口</li><li>传输层</li></ul><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续~"></a>未完待续~</h2>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言轻松入门</title>
      <link href="/post/87cd01d8.html"/>
      <url>/post/87cd01d8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言轻松入门"><a href="#Go语言轻松入门" class="headerlink" title="Go语言轻松入门"></a>Go语言轻松入门</h1><h2 id="1-Go环境配置"><a href="#1-Go环境配置" class="headerlink" title="1. Go环境配置"></a>1. Go环境配置</h2><h3 id="1-1-环境安装"><a href="#1-1-环境安装" class="headerlink" title="1.1 环境安装"></a>1.1 环境安装</h3><h4 id="主要有以下途径供选择（会使用魔法的可以直接使用第一种方法"><a href="#主要有以下途径供选择（会使用魔法的可以直接使用第一种方法" class="headerlink" title="主要有以下途径供选择（会使用魔法的可以直接使用第一种方法"></a>主要有以下途径供选择（会使用魔法的可以直接使用第一种方法</h4><ol><li><a href="https://go.dev/dl/">https://go.dev/dl/</a></li><li><a href="https://studygolang.com/dl">https://studygolang.com/dl</a></li></ol><h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4><p>打开CMD，输入go version，如若返回版本信息则为安装成功。</p><h3 id="1-2-IDE"><a href="#1-2-IDE" class="headerlink" title="1.2 IDE"></a>1.2 IDE</h3><ol><li>推荐<a href="https://www.jetbrains.com/go/promo/">Goland</a>，安装简单，使用体验舒适。</li><li>VsCode也有Go插件，但是配置好像挺麻烦的。</li><li><a href="https://1024code.com/">1024Code</a>字节推荐的在线编译器，免去一切环境配置的烦恼。</li></ol><h2 id="2-Go基础语法"><a href="#2-Go基础语法" class="headerlink" title="2. Go基础语法"></a>2. Go基础语法</h2><h3 id="2-1-第一个Go程序"><a href="#2-1-第一个Go程序" class="headerlink" title="2.1 第一个Go程序"></a>2.1 第一个Go程序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main作为执行的入口 所以这里应该写main 而main函数必须要在main包下面</span></span><br><span class="line"><span class="keyword">package</span> main  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在终端输入 <code>go run main.c</code> 即可得到程序执行结果。</p><p>当然也可以使用<code>go build main.go</code>得到二进制文件，然后<code>./main</code>执行。</p><h3 id="2-2-变量定义及初始化"><a href="#2-2-变量定义及初始化" class="headerlink" title="2.2 变量定义及初始化"></a>2.2 变量定义及初始化</h3><ol><li>普通变量<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var </span></span><br><span class="line"><span class="comment">// 变量名后面可用类型关键字</span></span><br><span class="line"><span class="comment">// 也可以省略,与Python类似会自动确定变量类型</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> d float <span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// :=</span></span><br><span class="line">e := <span class="type">float32</span>(e)</span><br><span class="line">f := a + <span class="string">&quot;foo&quot;</span></span><br></pre></td></tr></table></figure></li><li>常量<br>var改成const即可,变量名可省略<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> N <span class="type">int</span> = <span class="number">100010</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3-条件控制语句"><a href="#2-3-条件控制语句" class="headerlink" title="2.3 条件控制语句"></a>2.3 条件控制语句</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><p>需要写<code>&#123;&#125;</code> 不需要写<code>()</code></p><p>使用<code>GoLand</code>就算你不小心写了<code>()</code>,自动格式化的时候也会帮你去掉.</p><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    a := <span class="number">2</span></span><br><span class="line">    <span class="keyword">switch</span> a &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;one&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;two&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;three&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>, <span class="number">5</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;four or five&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;other&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    t := time.Now()</span><br><span class="line">    fmt.Println(<span class="string">&quot;the time now is &quot;</span> + strconv.Itoa(t.Hour()) + <span class="string">&quot;h&quot;</span>) <span class="comment">/* print the time&#x27;s hour now */</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;It&#x27;s before noon&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;It&#x27;s after noon&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4-for"><a href="#2-4-for" class="headerlink" title="2.4 for"></a>2.4 for</h3><p>go有且只有<code>for</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">// 死循环</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;loop&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">7</span>; j &lt; <span class="number">9</span>; j++ &#123;</span><br><span class="line">    fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">5</span>; n++ &#123;</span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span> &#123; <span class="comment">// 类似while</span></span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-5-数组"><a href="#2-5-数组" class="headerlink" title="2.5 数组"></a>2.5 数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> N <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">// tr := [N]int&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> tr [N]<span class="type">int</span> <span class="comment">// 初始化为0</span></span><br><span class="line">size := <span class="built_in">len</span>(tr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// tr := [N][N]int&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> tr [N][N]<span class="type">int</span></span><br></pre></td></tr></table></figure><h3 id="2-6-变长数组与切片"><a href="#2-6-变长数组与切片" class="headerlink" title="2.6 变长数组与切片"></a>2.6 变长数组与切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tr []<span class="type">int</span></span><br><span class="line">tr = <span class="built_in">append</span>(tr, <span class="number">1</span>)</span><br><span class="line">fmt.Println(tr)</span><br></pre></td></tr></table></figure><p>执行结果为 1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">tr = <span class="built_in">append</span>(tr, <span class="number">1</span>)</span><br><span class="line">fmt.Println(tr)</span><br></pre></td></tr></table></figure><p>执行结果为 0 0 0 1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr[l:r] <span class="comment">// 左闭右开</span></span><br></pre></td></tr></table></figure><h3 id="2-7-map"><a href="#2-7-map" class="headerlink" title="2.7 map"></a>2.7 map</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mp := make(map[string]int)&#123;&quot;a&quot; : 1, &quot;b&quot; : 2&#125;</span></span><br><span class="line">mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">mp[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span></span><br><span class="line">r, ok := m[<span class="string">&quot;a&quot;</span>] <span class="comment">// 存在ok=true 不存在ok=false r为空</span></span><br><span class="line"><span class="built_in">delete</span>(mp, <span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-8-range"><a href="#2-8-range" class="headerlink" title="2.8 range"></a>2.8 range</h3><p>给容器创建迭代器，遍历容器中的元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">2</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;index:&quot;</span>, i, <span class="string">&quot;num:&quot;</span>, num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">​</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;A&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;B&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;key&quot;</span>, k)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-9-函数-func"><a href="#2-9-函数-func" class="headerlink" title="2.9 函数 func"></a>2.9 函数 func</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10-指针"><a href="#2-10-指针" class="headerlink" title="2.10 指针"></a>2.10 指针</h3><p>修改传参</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">*x += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">n := <span class="number">1</span></span><br><span class="line">new_add(&amp;n)</span><br></pre></td></tr></table></figure><h3 id="2-11-struct"><a href="#2-11-struct" class="headerlink" title="2.11 struct"></a>2.11 struct</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name     <span class="type">string</span></span><br><span class="line">    password <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span></span> checkPassword(password <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> u.password == password</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span></span> resetPassword(password <span class="type">string</span>) &#123;</span><br><span class="line">    u.password = password</span><br><span class="line">&#125;</span><br><span class="line">    ​    ​</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := user&#123;name: <span class="string">&quot;wang&quot;</span>, password: <span class="string">&quot;1024&quot;</span>&#125;</span><br><span class="line">    a.resetPassword(<span class="string">&quot;2048&quot;</span>)</span><br><span class="line">    fmt.Println(a.checkPassword(<span class="string">&quot;2048&quot;</span>)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-12-error"><a href="#2-12-error" class="headerlink" title="2.12 error"></a>2.12 error</h3><p>函数返回中包括正常返回的结果和错误两种类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findUser</span><span class="params">(users []user, name <span class="type">string</span>)</span></span> (v *user, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, u := <span class="keyword">range</span> users &#123;</span><br><span class="line">        <span class="keyword">if</span> u.name == name &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;u, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-13-string"><a href="#2-13-string" class="headerlink" title="2.13 string"></a>2.13 string</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    fmt.Println(strings.Contains(a, <span class="string">&quot;ll&quot;</span>))                <span class="comment">// true</span></span><br><span class="line">    fmt.Println(strings.Count(a, <span class="string">&quot;l&quot;</span>))                    <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(strings.HasPrefix(a, <span class="string">&quot;he&quot;</span>))               <span class="comment">// true</span></span><br><span class="line">    fmt.Println(strings.HasSuffix(a, <span class="string">&quot;llo&quot;</span>))              <span class="comment">// true</span></span><br><span class="line">    fmt.Println(strings.Index(a, <span class="string">&quot;ll&quot;</span>))                   <span class="comment">// 2</span></span><br><span class="line">    fmt.Println(strings.Join([]<span class="type">string</span>&#123;<span class="string">&quot;he&quot;</span>, <span class="string">&quot;llo&quot;</span>&#125;, <span class="string">&quot;-&quot;</span>)) <span class="comment">// he-llo</span></span><br><span class="line">    fmt.Println(strings.Repeat(a, <span class="number">2</span>))                     <span class="comment">// hellohello</span></span><br><span class="line">    fmt.Println(strings.Replace(a, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="number">-1</span>))         <span class="comment">// hEllo, -1表示替换的数量没有限制</span></span><br><span class="line">    fmt.Println(strings.Split(<span class="string">&quot;a-b-c&quot;</span>, <span class="string">&quot;-&quot;</span>))              <span class="comment">// [a b c]</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">    fmt.Println(strings.ToLower(a)) <span class="comment">// hello</span></span><br><span class="line">    fmt.Println(strings.ToUpper(a)) <span class="comment">// HELLO</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(a))             <span class="comment">// 5</span></span><br><span class="line">    b := <span class="string">&quot;你好&quot;</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(b)) <span class="comment">// 6 一个中文字相当于3个英文字符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-14-json"><a href="#2-14-json" class="headerlink" title="2.14 json"></a>2.14 json</h3><p>保证每一个字段的第一个字母是大写!</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a := userInfo&#123;Name: <span class="string">&quot;wang&quot;</span>, Age: <span class="number">18</span>, Hobby: []<span class="type">string</span>&#123;<span class="string">&quot;Golang&quot;</span>, <span class="string">&quot;TypeScript&quot;</span>&#125;&#125;</span><br><span class="line">buf, err := json.Marshal(a) <span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(buf)) <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b userInfo</span><br><span class="line">err = json.Unmarshal(buf, &amp;b) <span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-15-time"><a href="#2-15-time" class="headerlink" title="2.15 time"></a>2.15 time</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">t := time.Date(<span class="number">2022</span>, <span class="number">3</span>, <span class="number">27</span>, <span class="number">1</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">0</span>, time.UTC)</span><br><span class="line">fmt.Println(t)<span class="comment">// 2022-03-27 01:25:36 +0000 UTC</span></span><br><span class="line">fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute()) <span class="comment">// 2022 March 27 1 25</span></span><br><span class="line">fmt.Println(t.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)) <span class="comment">// 2022-03-27 01:25:36 格式化t</span></span><br><span class="line"></span><br><span class="line">diff := t2.Sub(t) <span class="comment">// 时间差</span></span><br><span class="line">fmt.Println(diff) <span class="comment">// 1h5m0s</span></span><br><span class="line">fmt.Println(diff.Minutes(), diff.Seconds()) <span class="comment">// 65 3900</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定时间格式化成time类型</span></span><br><span class="line">t3, err := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2022-03-27 01:25:36&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t3 == t)    <span class="comment">// true</span></span><br><span class="line">fmt.Println(now.Unix()) <span class="comment">// 1648738080 时间戳</span></span><br></pre></td></tr></table></figure><h3 id="2-16-strconv"><a href="#2-16-strconv" class="headerlink" title="2.16 strconv"></a>2.16 strconv</h3><p>数字解析，以及转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">f, _ := strconv.ParseFloat(<span class="string">&quot;1.234&quot;</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(f) <span class="comment">// 1.234</span></span><br><span class="line">​</span><br><span class="line">n, _ := strconv.ParseInt(<span class="string">&quot;111&quot;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(n) <span class="comment">// 111</span></span><br><span class="line">​</span><br><span class="line">n, _ = strconv.ParseInt(<span class="string">&quot;0x1000&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">fmt.Println(n) <span class="comment">// 4096</span></span><br><span class="line">​</span><br><span class="line">n2, _ := strconv.Atoi(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">fmt.Println(n2) <span class="comment">// 123</span></span><br><span class="line">​</span><br><span class="line">n2, err := strconv.Atoi(<span class="string">&quot;AAA&quot;</span>)</span><br><span class="line">fmt.Println(n2, err) <span class="comment">// 0 strconv.Atoi: parsing &quot;AAA&quot;: invalid syntax</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-17-进程信息，获取系统参数"><a href="#2-17-进程信息，获取系统参数" class="headerlink" title="2.17 进程信息，获取系统参数"></a>2.17 进程信息，获取系统参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// go run example/20-env/main.go a b c d</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Args:&quot;</span>, os.Args)           <span class="comment">// [/var/folders/8p/n34xxfnx38dg8bv_x8l62t_m0000gn/T/go-build3406981276/b001/exe/main a b c d]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Path:&quot;</span>, os.Getenv(<span class="string">&quot;PATH&quot;</span>)) <span class="comment">// /usr/local/go/bin...</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Set:&quot;</span>, os.Setenv(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>))</span><br><span class="line">​</span><br><span class="line">buf, err := exec.Command(<span class="string">&quot;grep&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;/etc/hosts&quot;</span>).CombinedOutput()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(buf)) <span class="comment">// 127.0.0.1       localhost</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-18-标准输入输出"><a href="#2-18-标准输入输出" class="headerlink" title="2.18 标准输入输出"></a>2.18 标准输入输出</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="type">int</span></span><br><span class="line"><span class="comment">//空格 or 回车分割</span></span><br><span class="line">fmt.Scan(&amp;name, &amp;age)</span><br><span class="line"><span class="comment">//空格分割 回车结束</span></span><br><span class="line">fmt.Scanln(&amp;name, &amp;age)</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%s%d&quot;</span>, &amp;name, &amp;age)</span><br><span class="line"></span><br><span class="line">    fmt.Println()</span><br><span class="line">fmt.Printf()</span><br><span class="line">fmt.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用资料"><a href="#常用资料" class="headerlink" title="常用资料"></a>常用资料</h2><ol><li><a href="https://go.dev/doc/">https://go.dev/doc/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间DP模型</title>
      <link href="/post/55265d54.html"/>
      <url>/post/55265d54.html</url>
      
        <content type="html"><![CDATA[<h1 id="区间DP模型"><a href="#区间DP模型" class="headerlink" title="区间DP模型"></a>区间DP模型</h1><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><ol><li>迭代式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for len = 2; len &lt;= n; len ++</span><br><span class="line">    for i = 1; i + len - 1 &lt;= n; i ++ </span><br><span class="line">        j = i + len - 1</span><br></pre></td></tr></table></figure></li></ol><h2 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a><a href="https://www.acwing.com/problem/content/description/284/">石子合并</a></h2><p>状态表示 <code>f[i][j]</code><br>    集合 所有将从i到j合并的方案<br>    属性 <code>Min</code><br>状态计算 <code>f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[i][j])</code>  <code>for(k : [i, j])</code>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; s[i], s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) f[i][i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len ++) <span class="comment">// 枚举长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++) <span class="comment">// 枚举左端点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>; <span class="comment">// 得到右端点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i; k + <span class="number">1</span> &lt;= j; k ++) <span class="comment">// 枚举划分区间</span></span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="number">1</span>][j] + s[j] - s[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拆环成链"><a href="#拆环成链" class="headerlink" title="拆环成链"></a>拆环成链</h2><h3 id="AcWing-1068-环形石子合并"><a href="#AcWing-1068-环形石子合并" class="headerlink" title="AcWing 1068. 环形石子合并"></a><a href="https://www.acwing.com/activity/content/code/add/1297/">AcWing 1068. 环形石子合并</a></h3><p>破环成链 双倍区间 套用模板 枚举区间长度为n</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">410</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> f[N][N], s[N], g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; s[i], s[i + n] = s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i ++) s[i] += s[i - <span class="number">1</span>], f[i][i] = g[i][i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= <span class="number">2</span> * n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> x = s[j] - s[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i; k + <span class="number">1</span> &lt;= j; k ++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k] + f[k + <span class="number">1</span>][j] + x);</span><br><span class="line">                g[i][j] = <span class="built_in">max</span>(g[i][j], g[i][k] + g[k + <span class="number">1</span>][j] + x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> Min = inf, Max = -inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        Min = <span class="built_in">min</span>(Min, f[i][i + n - <span class="number">1</span>]);</span><br><span class="line">        Max = <span class="built_in">max</span>(Max, g[i][i + n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; Min &lt;&lt; endl &lt;&lt; Max;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-320-能量项链"><a href="#AcWing-320-能量项链" class="headerlink" title="AcWing 320. 能量项链"></a><a href="https://www.acwing.com/problem/content/322/">AcWing 320. 能量项链</a></h3><p>状态表示 <code>f[i][j]</code><br>    集合 所有将<code>[i,j]</code>合并成一个珠子的集合<br>    属性 <code>Max</code><br>状态计算 <code>f[i][j] = max(f[i][j], f[i][k] + f[k][j] + w[i] * w[j] * w[k])</code><br>例子 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 3 5 10 -&gt; 2 3 5 10 2 </span><br><span class="line">ans = f[1][5]</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> w[N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; w[i], w[i + n] = w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">3</span>; len &lt;= n + <span class="number">1</span>; len++) <span class="comment">// len 小于 3的时候f[i][j] == 0 因此不用初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= <span class="number">2</span> * n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k + <span class="number">1</span> &lt;= j; k++) <span class="comment">// 由于需要计算 w[i] * w[j] * w[k] 因此k != i != j</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][k] + f[k][j] + w[i] * w[j] * w[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, f[i][i + n]);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="记录具体方案"><a href="#记录具体方案" class="headerlink" title="记录具体方案"></a>记录具体方案</h2><h3 id="加分二叉树"><a href="#加分二叉树" class="headerlink" title="加分二叉树"></a><a href="https://www.acwing.com/problem/content/481/">加分二叉树</a></h3><p><a href="https://www.acwing.com/solution/content/3804/">题解</a><br>状态表示 <code>f[i][j]</code><br>    集合 所有中序遍历是<code>I~J</code>这一段的二叉树的集合<br>    属性 <code>Max</code><br>状态计算 找根节点<code>k(I~J)</code><br>    <code>f[i][j] = max(f[i][j], f[i][k - 1] * f[k + 1][j] + w[k])</code>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> w[N], f[N][N], g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> root = g[l][r];</span><br><span class="line">    cout &lt;&lt; root &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(l, root - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(root + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = w[i];</span><br><span class="line">                g[i][j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= j; k ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> left = i == k ? <span class="number">1</span> : f[i][k - <span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> right = j == k ? <span class="number">1</span> : f[k + <span class="number">1</span>][j];</span><br><span class="line">                    <span class="type">int</span> score = w[k] + left * right;</span><br><span class="line">                    <span class="keyword">if</span>(score &gt; f[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        f[i][j] = score;</span><br><span class="line">                        g[i][j] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间DP-高精度"><a href="#区间DP-高精度" class="headerlink" title="区间DP + 高精度"></a>区间DP + 高精度</h2><h3 id="AcWing-1069-凸多边形的划分"><a href="#AcWing-1069-凸多边形的划分" class="headerlink" title="AcWing 1069. 凸多边形的划分"></a><a href="https://www.acwing.com/problem/content/1071/">AcWing 1069. 凸多边形的划分</a></h3><p>状态表示 <code>f[i][j]</code><br>    集合 所有将<code>(i, i + 1)(i + 1, i + 2)...(j - 1, j)(j, i)</code>多边形划分成三角形的方案<br>    属性 Min<br>状态计算 <code>f[i][j] = min(f[i][k], f[k][j] + w[i] * w[j] * w[k])</code>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">60</span>, M = <span class="number">35</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL f[N][N][<span class="number">35</span>];</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(LL a[], LL b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> LL c[M];</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; M; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] + b[i];</span><br><span class="line">        c[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a, c, <span class="keyword">sizeof</span> c); <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(LL a[], LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> LL c[M];</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">    LL t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a, c, <span class="keyword">sizeof</span> c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(LL a[], LL b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = M - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; b[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &lt; b[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(LL a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = M - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &amp;&amp; !a[k]) k --;</span><br><span class="line">    <span class="keyword">while</span>(k &gt;= <span class="number">0</span>) cout &lt;&lt; a[k --];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    LL temp[M];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">3</span>; len &lt;= n; len ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            f[i][j][M - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span>; k + <span class="number">1</span> &lt;= j; k ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="keyword">sizeof</span> temp);</span><br><span class="line">                temp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">mul</span>(temp, w[i]); <span class="built_in">mul</span>(temp, w[k]); <span class="built_in">mul</span>(temp, w[j]);</span><br><span class="line">                <span class="built_in">add</span>(temp, f[i][k]); <span class="built_in">add</span>(temp, f[k][j]);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">cmp</span>(f[i][j], temp) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">memcpy</span>(f[i][j], temp, <span class="keyword">sizeof</span> temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">print</span>(f[<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维区间DP"><a href="#二维区间DP" class="headerlink" title="二维区间DP"></a>二维区间DP</h2><h3 id="AcWing-321-棋盘分割"><a href="#AcWing-321-棋盘分割" class="headerlink" title="AcWing 321. 棋盘分割"></a><a href="https://www.acwing.com/activity/content/code/add/1301/">AcWing 321. 棋盘分割</a></h3><p><a href="https://www.acwing.com/solution/content/62836/">题解</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">20</span>, M = <span class="number">9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, m = <span class="number">8</span>;</span><br><span class="line"><span class="type">double</span> s[N][N], X, f[M][M][M][M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] - X;</span><br><span class="line">    <span class="keyword">return</span> sum * sum / n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> &amp;v = f[x1][y1][x2][y2][k];</span><br><span class="line">    <span class="keyword">if</span>(v &gt;= <span class="number">0</span>) <span class="keyword">return</span> v; <span class="comment">// 记忆化搜索</span></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> v = <span class="built_in">get</span>(x1, y1, x2, y2); <span class="comment">// 分一个棋盘 直接就是结果</span></span><br><span class="line">    </span><br><span class="line">    v = INF;</span><br><span class="line">    <span class="comment">// 遍历横切</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x1; i + <span class="number">1</span> &lt;= x2; i ++) <span class="comment">//这里之所以 i==x1 是因为这里是按格子来切的 举第一个例子就明白了 切成(上面是 x1,y1 到 x1,y2 下面是 x1 + 1,y1 到 x2,y2)</span></span><br><span class="line">    &#123;</span><br><span class="line">        v = <span class="built_in">min</span>(v, <span class="built_in">dfs</span>(x1, y1, i, y2, k - <span class="number">1</span>) + <span class="built_in">get</span>(i + <span class="number">1</span>, y1, x2, y2)); <span class="comment">// 切出来的上面继续分 下面的保留</span></span><br><span class="line">        v = <span class="built_in">min</span>(v, <span class="built_in">dfs</span>(i + <span class="number">1</span>, y1, x2, y2, k - <span class="number">1</span>) + <span class="built_in">get</span>(x1, y1, i, y2)); <span class="comment">// 同理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = y1; i + <span class="number">1</span> &lt;= y2; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        v = <span class="built_in">min</span>(v, <span class="built_in">dfs</span>(x1, y1, x2, i, k - <span class="number">1</span>) + <span class="built_in">get</span>(x1, i + <span class="number">1</span>, x2, y2));</span><br><span class="line">        v = <span class="built_in">min</span>(v, <span class="built_in">dfs</span>(x1, i + <span class="number">1</span>, x2, y2, k - <span class="number">1</span>) + <span class="built_in">get</span>(x1, y1, x2, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">8</span>; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; s[i][j];</span><br><span class="line">            s[i][j] += s[i][j - <span class="number">1</span>] + s[i - <span class="number">1</span>][j] - s[i - <span class="number">1</span>][j - <span class="number">1</span>]; <span class="comment">// 读取棋盘  处理二维前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    X = (<span class="type">double</span>)s[m][m] / n; <span class="comment">// 获取平均值 注意这里是 总和除以最后棋盘个数</span></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f); <span class="comment">// double初始化为Nan</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, <span class="built_in">sqrt</span>(<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">8</span>, n)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间DP </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学知识</title>
      <link href="/post/374e1302.html"/>
      <url>/post/374e1302.html</url>
      
        <content type="html"><![CDATA[<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p>在大于1的整数中，如果只包含1和本身这两个约数，就被称为约数，或者叫素数。<br>    质数定理: 1~n中有 n&#x2F;ln(n) 个质数</p><h3 id="1-质数的判定-试除法"><a href="#1-质数的判定-试除法" class="headerlink" title="1. 质数的判定-试除法"></a>1. 质数的判定-试除法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= x / i;i++)</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-分解质因数-试除法"><a href="#2-分解质因数-试除法" class="headerlink" title="2. 分解质因数-试除法"></a>2. 分解质因数-试除法</h3><pre><code>n中最多只包含一个大于sqrt(n)的质因子</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="comment">// i 一定是质数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-筛质数"><a href="#3-筛质数" class="headerlink" title="3. 筛质数"></a>3. 筛质数</h3><h4 id="朴素筛法"><a href="#朴素筛法" class="headerlink" title="朴素筛法"></a>朴素筛法</h4><pre><code>时间复杂度: n/2 + n/3 + ... + n/n = n(1/2 + 1/3 + ... + 1/n) 调和级数ln(n) &lt; log2(n) 因此时间复杂度可表示为O(nlgn)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h4><p>优化: 只需筛掉质数的所有倍数 O(nloglogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">                st[j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a>线性筛法</h4><p>数据范围1e7时，比埃氏筛法快1倍  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;primes[j] &lt;= n / i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// primes[j]一定是i的最小质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++) <span class="comment">// 枚举到sqrt(n) 只筛小的约数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != n / i) res.<span class="built_in">insert</span>(n / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><pre><code>分解质因数之后公式：N=(α1+1)(α2+1)(α3+1)…(αk+1)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">while</span> (n--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= x / i;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x /= i;</span><br><span class="line">            primes[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) primes[x]++;</span><br><span class="line">&#125;</span><br><span class="line">LL  res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item : primes) res = res * (<span class="number">1</span> + item.second) % mod ;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h3><pre><code>公式：Sum=(1+p1+p1^2+…+p1^α1)(1+p2+p2^2+…+p2^α2)…(1+pk+pk^2+…+p1^αk)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t = 1 while(a--) t = t * p + 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> item : primes) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = item.first, a = item.second;</span><br><span class="line">    LL t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a--)</span><br><span class="line">    &#123;</span><br><span class="line">        t = (t * p + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    res = res * t % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧几里得算法（辗转相除法）"><a href="#欧几里得算法（辗转相除法）" class="headerlink" title="欧几里得算法（辗转相除法）"></a>欧几里得算法（辗转相除法）</h3><pre><code>d|a d|b 那么 d|(ax+by)(a, b) = (b, a mod b)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//__gcd(a,b) #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><pre><code>定义：1~n中与n互质的数的个数分解质因数 N = p1^α1*p2^α2...pk^αkφ(N) = N(1 - 1/p1)(1 - 1/p2)...(1 - 1/pk)</code></pre><h3 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="type">int</span> res = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= x / i;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            x /= i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><pre><code>线性筛法 i mod pj == 0 :    φ(pj * i) = pj * φ(i) 因为pj是i的最小质因子i mod pj != 0 :     φ(pj * i) = pj * φ(i) * (1 - 1/pj) = φ(i) * (pj - 1)    pj 是pj*i的最小质因子且pj不在i的质因子当中的</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求1~n欧拉函数之和</span></span><br><span class="line"><span class="function">LL <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;primes[j] &lt;= n / i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[primes[j] * i] = phi[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//e[pj*i] = e[i]*pj*(1-1/pj) = e[i]*</span></span><br><span class="line">            phi[primes[j] * i] = phi[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) res += phi[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><pre><code>a和n互质 则a^φ(n) 同余 1 (mod n)a^φ(n) mod n = 1 费马定理 a^(p-1) % (p-1) = 1</code></pre><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><pre><code>O(logk) 求 a^k mod p</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * (LL)a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h3><pre><code>规定p为质数1. a p互质    由费马定理 a^(p-1) = 1 (mod p) 由 a * a^(p-2) = 1 (mod p)    res = qmi(a, p - 2, p);2. 不存在</code></pre><h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><pre><code>裴蜀定理：对于任意正整数a,b,一定存在非零整数x,y，使得ax+by = (a,b)(a, b) = (b, a % b)1. (a, 0) = a  x = 1 y = 02. return (b, a % b) = d = by + (a mod b)x = by + (a - [a/b]*b)x    整理得到 ax + b(y - [a/b]*x) = d    故 x = x y = y - [a/b]*x</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y = y - a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性同余"><a href="#线性同余" class="headerlink" title="线性同余"></a>线性同余</h3><p>$a_i × x_i ≡ b_i (mod\ m_i)$</p><p>化简为 $ax + my &#x3D; b$</p><p>由扩展欧几里得 $ax + my &#x3D; d &#x3D; (a,b)$</p><p>因此若b为d的倍数，则$x &#x3D; x × (b&#x2F;d) % m$</p><pre><code>若m不为质数 只能使用该方法求逆元 快速幂求逆元要求m为质数</code></pre><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>x &#x3D; a<sub>1</sub> * M<sub>1</sub> * M<sub>1</sub><sup>-1</sup> + …</p><h1 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h1><p>在$n^3$时间复杂度求出非齐次线性方程组 最简阶梯型矩阵</p><p>有3种情况</p><pre><code>1. 无解 0 != 02. 无穷多解 出现 0 == 03. 唯一解 满秩</code></pre><p>0表示唯一解 1表示无穷解 2表示无解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r; <span class="comment">// column表示列 row表示行</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c])) <span class="comment">// 找到次列绝对值最大的行</span></span><br><span class="line">                t = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>; <span class="comment">// 全为0不用消啦</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++) <span class="built_in">swap</span>(a[t][i], a[r][i]);  <span class="comment">// 将绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i--) a[r][i] /= a[r][c]; <span class="comment">// 将当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j--)</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 无穷多解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">gauss</span>();</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][n]) &lt; eps) a[i][n] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, a[i][n]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Infinite group solutions&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No solution&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h1><h2 id="递推-1e3-1e3"><a href="#递推-1e3-1e3" class="headerlink" title="递推 1e3*1e3"></a>递推 1e3*1e3</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c[i][j] = c[i-1][j] + c[i - 1][j - 1]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)</span><br><span class="line">            <span class="keyword">if</span>(!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> c[i][j] = (c[i<span class="number">-1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递推-1e5-1e5"><a href="#递推-1e5-1e5" class="headerlink" title="递推 1e5 * 1e5"></a>递推 1e5 * 1e5</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C(a,b) == (LL)fact[a] * infact[b] % mod * infact[a - b] % mod </span></span><br><span class="line"><span class="comment">// a! / b!(a - b)!</span></span><br></pre></td></tr></table></figure><h2 id="lucas"><a href="#lucas" class="headerlink" title="lucas"></a>lucas</h2><p>C(a,b) 同余 C(a%p,b%p) * C(a&#x2F;p,b&#x2F;p) (mod p)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b &gt; a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; i--, j ++)</span><br><span class="line">    &#123;</span><br><span class="line">        res = (LL)res * i % p;</span><br><span class="line">        res = (LL) res * <span class="built_in">qmi</span>(j, p - <span class="number">2</span>, p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a, b;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">lucas</span>(a, b, p) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> primes[N], cnt, st[N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;primes[j] &lt;= n / i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += b * a[i];</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">get_primes</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = primes[i];</span><br><span class="line">        sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; cnt;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;j &lt; sum[i];j++)</span><br><span class="line">            res = <span class="built_in">mul</span>(res, primes[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) cout &lt;&lt; res[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><pre><code>火车进站 括号序列 01串C(2n,n) - C(2n,n-1) = C(2n,n)/(n+1)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> a = <span class="number">2</span> * n, b = n;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; i--, j++)</span><br><span class="line">&#123;</span><br><span class="line">    res = (LL)res * i % mod;</span><br><span class="line">    res = (LL)res * <span class="built_in">qmi</span>(j, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line">res = (LL)res * <span class="built_in">qmi</span>(n + <span class="number">1</span>, mod - <span class="number">2</span>, mod) % mod;</span><br></pre></td></tr></table></figure><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><pre><code>C(n,0) + C(n,1) + .. + C(n,n) = 2^n可以看成 求n个物品的所有组合方案这就是容斥原理的时间复杂度</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//能被整除的数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) cin &gt;&gt; p[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="keyword">if</span> (i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((LL)t * p[j] &gt; n)</span><br><span class="line">&#123;</span><br><span class="line">t = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">t *= p[j];</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">2</span>) res += n / t;</span><br><span class="line">            <span class="keyword">else</span> res -= n / t;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单博弈论"><a href="#简单博弈论" class="headerlink" title="简单博弈论"></a>简单博弈论</h1><pre><code>先手必胜态：可以走到某一个必败状态先手必败态：走不到任何一个必败状态</code></pre><h2 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h2><p>$a_1⊕a_2⊕ … ⊕a_n &#x3D; x$<br>if(x) 先手必胜<br>else 后手必胜</p><h3 id="台阶Nim游戏"><a href="#台阶Nim游戏" class="headerlink" title="台阶Nim游戏"></a>台阶Nim游戏</h3><pre><code>只需处理奇数台阶上的数</code></pre><h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><pre><code>在有向图游戏中,对于每个节点x,设从x出发共有k条有向边,分别到达节点y1,y2,····yk,定义SG(x)的后记节点y1,y2,····yk的SG函数值构成的集合在执行mex运算的结果,即:SG(x)=mex(&#123;SG(y1),SG(y2)····SG(yk)&#125;)特别地,整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值,即 SG(G)=SG(s).</code></pre><h3 id="集合Nim游戏"><a href="#集合Nim游戏" class="headerlink" title="集合Nim游戏"></a>集合Nim游戏</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> s[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f[x] != <span class="number">-1</span>) <span class="keyword">return</span> f[x];</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] &gt; x) <span class="keyword">continue</span>;</span><br><span class="line">S.<span class="built_in">insert</span>(<span class="built_in">sg</span>(x - s[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ; i++)</span><br><span class="line"><span class="keyword">if</span> (!S.<span class="built_in">count</span>(i))</span><br><span class="line"><span class="keyword">return</span> f[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) cin &gt;&gt; s[i];</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">res ^= <span class="built_in">sg</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拆分Nim"><a href="#拆分Nim" class="headerlink" title="拆分Nim"></a>拆分Nim</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sg</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (f[x] != <span class="number">-1</span>) <span class="keyword">return</span> f[x];</span><br><span class="line"></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">S.<span class="built_in">insert</span>(<span class="built_in">sg</span>(i) ^ <span class="built_in">sg</span>(j));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ;i++)</span><br><span class="line"><span class="keyword">if</span> (!S.<span class="built_in">count</span>(i))</span><br><span class="line"><span class="keyword">return</span> f[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">res ^= <span class="built_in">sg</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (res) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相邻两个自然数互质</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异或前缀和</span></span><br><span class="line">s[i] = s[i<span class="number">-1</span>] ^ a[i];</span><br><span class="line"><span class="comment">//l ~ r</span></span><br><span class="line">s[r] ^ s[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已知正方形两点坐标 求另外两点</span></span><br><span class="line"><span class="type">int</span> x3 = x2 - (y2 - y1);</span><br><span class="line"><span class="type">int</span> y3 = y2 - (x1 - x2);</span><br><span class="line"><span class="type">int</span> x4 = x1 - (y2 - y1);</span><br><span class="line"><span class="type">int</span> y4 = y1 - (x1 - x2);</span><br></pre></td></tr></table></figure><h1 id="分拆数"><a href="#分拆数" class="headerlink" title="分拆数"></a>分拆数</h1><h2 id="k部分分拆数"><a href="#k部分分拆数" class="headerlink" title="k部分分拆数"></a>k部分分拆数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL f[<span class="number">2500</span>][<span class="number">30</span>]; <span class="comment">// f[i][j]表示将i拆分成j个数相加的方案数</span></span><br><span class="line"><span class="comment">// 集合划分 1. 包含1 f[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">//         2. 所有数都大于1 f[i - j][j]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">2022</span>, k = <span class="number">10</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= k;j++)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j];</span><br><span class="line">    cout &lt;&lt; f[<span class="number">2022</span>][<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="k部分互异分拆数"><a href="#k部分互异分拆数" class="headerlink" title="k部分互异分拆数"></a>k部分互异分拆数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL f[<span class="number">2500</span>][<span class="number">30</span>];</span><br><span class="line"><span class="comment">// 集合划分 有1 f[i - k][k - 1]</span></span><br><span class="line"><span class="comment">//         无1 f[i - k][k]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">2022</span>, k = <span class="number">10</span>;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= k;j++)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">                f[i][j] = f[i - j][j - <span class="number">1</span>] + f[i - j][j];</span><br><span class="line">    cout &lt;&lt; f[<span class="number">2022</span>][<span class="number">10</span>]; </span><br><span class="line"><span class="comment">// 379187662194355221</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字三角形模型</title>
      <link href="/post/ce1c1551.html"/>
      <url>/post/ce1c1551.html</url>
      
        <content type="html"><![CDATA[<pre><code>集合划分原则1. 不重复(求Max Min Bool的时候可以不用满足该原则)2. 不遗漏</code></pre><h1 id="原模型"><a href="#原模型" class="headerlink" title="原模型"></a><a href="https://www.acwing.com/problem/content/900/">原模型</a></h1><pre><code>f[i][j] += max(f[i - 1][j], f[i - 1][j - 1])需要注意正负号、初始化等问题</code></pre><h1 id="AcWing-1015-摘花生"><a href="#AcWing-1015-摘花生" class="headerlink" title="AcWing 1015. 摘花生"></a><a href="https://www.acwing.com/problem/content/1017/">AcWing 1015. 摘花生</a></h1><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], f[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, dy[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x + dx[i], v = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(u &gt;= <span class="number">1</span> &amp;&amp; u &lt;= n &amp;&amp; v &gt;= <span class="number">1</span> &amp;&amp; v &lt;= m)</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(u, v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][y] = res + a[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]), f[i][j] = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h2><pre><code>f[i][j] = max(f[i - 1][j], f[i][j - 1]) + a[i][j]</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// f[i][j] = max(f[i - 1][j], f[i][j - 1]) + a[i][j];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]), f[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]) + a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-1018-最低通行费"><a href="#AcWing-1018-最低通行费" class="headerlink" title="AcWing 1018. 最低通行费"></a><a href="https://www.acwing.com/problem/content/1020/">AcWing 1018. 最低通行费</a></h1><pre><code>不超过2n-1步说明了只能先下或向右走 本质就是摘花生原题 max -&gt; min且由于求的是最小，值需要特判边界</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> w[N][N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) f[i][j] = w[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>) f[i][j] = f[i][j - <span class="number">1</span>] + w[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">1</span>) f[i][j] = f[i - <span class="number">1</span>][j] + w[i][j];</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]) + w[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-1027-方格取数"><a href="#AcWing-1027-方格取数" class="headerlink" title="AcWing 1027. 方格取数"></a><a href="https://www.acwing.com/problem/content/1029/">AcWing 1027. 方格取数</a></h1><pre><code>走两次取最大值 同样一个数只能被选一遍 被选过置为0</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>f[i1][j1][i2][j2]表示所有从(1,1) (1,1) 分别走到(i1,j1) (i2,j2)的路径的最大值问题? 如何处理 同一个格子不能被重复选择只有在i1 + j1 == i2 + j2时，两条路径的格子才可能重合定义f[k][i1][i2] 表示所有从(1,1) (1,1) 分别走到(i1,k-i1) (i2,k-i2)的路径的最大值k表示两条路线当前走到的格子的横纵坐标之和即k == i1 + j1 == i2 + j2集合划分：两条路线就有4种走法 0表示向下1表示向右    00 01 10 11针对00这一种情况    f[k - 1][i1 - 1][i2 - 1] 考虑此时两点是否重合 即i1 == i2     若i1 == i2 则 w[i1][j1]    否则 w[i1][j1] + w[i2][j2]</code></pre><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> M = <span class="number">2</span> * N - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> f[M][N][N], w[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> x, y, W;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; x &gt;&gt; y &gt;&gt; W)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> &amp;&amp; W == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        w[x][y] = W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k &lt;= <span class="number">2</span> * n; k ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i1 = <span class="number">1</span>; i1 &lt;= n; i1 ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2 = <span class="number">1</span>; i2 &lt;= n; i2 ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j1 = k - i1, j2 = k - i2;</span><br><span class="line">                <span class="keyword">if</span>(j1 &gt;= <span class="number">1</span> &amp;&amp; j1 &lt;= n &amp;&amp; j2 &gt;= <span class="number">1</span> &amp;&amp; j2 &lt;= n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> t = w[i1][j1];</span><br><span class="line">                    <span class="keyword">if</span>(i1 != i2) t += w[i2][j2];</span><br><span class="line">                    <span class="type">int</span> &amp;x = f[k][i1][i2];</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2] + t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; f[<span class="number">2</span> * n][n][n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-275-传纸条"><a href="#AcWing-275-传纸条" class="headerlink" title="AcWing 275. 传纸条"></a><a href="https://www.acwing.com/problem/content/277/">AcWing 275. 传纸条</a></h1><pre><code>除了首尾 每个格子只能走一次但是!!!最优解就保证了每个格子只被走过一次 因此直接修改[方格取数]的输入输出即可</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span> f[M][N][N];</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k &lt;= n + m; k ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i1 = <span class="number">1</span>; i1 &lt;= n; i1 ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2 = <span class="number">1</span>; i2 &lt;= n; i2 ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j1 = k - i1, j2 = k - i2;</span><br><span class="line">                <span class="keyword">if</span>(j1 &gt;= <span class="number">1</span> &amp;&amp; j1 &lt;= m &amp;&amp; j2 &gt;= <span class="number">1</span> &amp;&amp; j2 &lt;= m)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> t = w[i1][j1];</span><br><span class="line">                    <span class="keyword">if</span>(i1 != i2) t += w[i2][j2];</span><br><span class="line">                    <span class="type">int</span> &amp;x = f[k][i1][i2];</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2] + t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; f[n + m][n][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 数字三角形模型 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态机模型</title>
      <link href="/post/354d9e7f.html"/>
      <url>/post/354d9e7f.html</url>
      
        <content type="html"><![CDATA[<h1 id="状态机模型"><a href="#状态机模型" class="headerlink" title="状态机模型"></a>状态机模型</h1><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>初始化状态(入口)：只有2种情况 </p><ol><li>要么初始化成0   表示该状态是合法的</li><li>要么初始化成无穷 表示该状态是违法的</li></ol><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><h3 id="AcWing-1049-大盗阿福"><a href="#AcWing-1049-大盗阿福" class="headerlink" title="AcWing 1049. 大盗阿福"></a><a href="https://www.acwing.com/problem/content/1051/">AcWing 1049. 大盗阿福</a></h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p><code>f[i]</code> 表示抢前i家店铺的最大收益<br>转移方程<code>f[i] = max(f[i - 2] + w, f[i - 1)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cin &gt;&gt; f[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> w;</span><br><span class="line">            cin &gt;&gt; w;</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i - <span class="number">2</span>] + w, f[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><ol><li>状态表示<code>f[i][0]</code> <code>f[i][1]</code><ol><li>集合 所有走了<code>i</code>步且当前位于状态<code>j</code>的所有走法</li><li>属性 <code>Max</code></li></ol></li><li>状态计算<ol><li>f[i][0] 最后一步<code>0 -&gt; 0</code> ; 最后一步<code>1 -&gt; 0</code><br> <code>f[i][0] = max(f[i - 1][0], f[i - 1][1])</code></li><li>f[i][1] 最后一步<code>0 - &gt; 1</code><br> <code>f[i][1] = f[i - 1][0] + w</code></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i];</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">1</span>][<span class="number">1</span>] = w[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            f[i][<span class="number">1</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">max</span>(f[n][<span class="number">0</span>], f[n][<span class="number">1</span>]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-1057-股票买卖-IV"><a href="#AcWing-1057-股票买卖-IV" class="headerlink" title="AcWing 1057. 股票买卖 IV"></a><a href="https://www.acwing.com/problem/content/1059/">AcWing 1057. 股票买卖 IV</a></h3><p><code>f[i][j][0]</code> 所有只考虑前i天 且<code>已经进行完j次交易</code> 且手中无货的所有购买方式的集合<br><code>f[i][j][1]</code> 所有只考虑前i天 且<code>正在进行第j次交易</code> 且手中有货的所有购买方式的集合<br><code>Max</code><br><code>f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + w)</code> &#x2F;&#x2F; 无货-&gt;无货 有货-&gt;无货<br><code>f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - w)</code> &#x2F;&#x2F; 无货-&gt;有货 有货-&gt;有货</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">100010</span>, M = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][M][<span class="number">2</span>], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) f[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j][<span class="number">0</span>], f[i - <span class="number">1</span>][j][<span class="number">1</span>]     + w[i]);</span><br><span class="line">            f[i][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j][<span class="number">1</span>], f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] - w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//枚举所有交易次数</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) res = <span class="built_in">max</span>(res, f[n][i][<span class="number">0</span>]); <span class="comment">// 必定是完整的交易</span></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-1058-股票买卖-V"><a href="#AcWing-1058-股票买卖-V" class="headerlink" title="AcWing 1058. 股票买卖 V"></a><a href="https://www.acwing.com/problem/content/1060/">AcWing 1058. 股票买卖 V</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">4</span>]; <span class="comment">// 0有货 1无货 2冻结</span></span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">0</span>], f[i - <span class="number">1</span>][<span class="number">1</span>] - w[i]);</span><br><span class="line">        f[i][<span class="number">1</span>] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][<span class="number">1</span>], f[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        f[i][<span class="number">2</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + w[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[n][<span class="number">1</span>], f[n][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 状态机模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形DP</title>
      <link href="/post/9ba26914.html"/>
      <url>/post/9ba26914.html</url>
      
        <content type="html"><![CDATA[<h1 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h1><h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><h3 id="经典做法-边权为1"><a href="#经典做法-边权为1" class="headerlink" title="经典做法(边权为1)"></a>经典做法(边权为1)</h3><ol><li>任取一点作为起点，找到距离该点最远的一个点u. DFS BFS</li><li>再找到距离u最远的点v. DFS BFS<br>那么u和v之间的路径就是一条直径</li></ol><h3 id="边权无限制-树形DP"><a href="#边权无限制-树形DP" class="headerlink" title="边权无限制-树形DP"></a>边权无限制-树形DP</h3><h4 id="AcWing-1072-树的最长路径"><a href="#AcWing-1072-树的最长路径" class="headerlink" title="AcWing 1072. 树的最长路径"></a><a href="https://www.acwing.com/problem/content/1074/">AcWing 1072. 树的最长路径</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], idx, st[N], w[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> <span class="comment">// 返回点u的深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> d1 = <span class="number">0</span>, d2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> d = <span class="built_in">dfs</span>(j) + w[i];</span><br><span class="line">            <span class="keyword">if</span> (d &gt; d1) d2 = d1, d1 = d;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (d &gt; d2) d2 = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d1 + d2);  <span class="comment">// 答案就是左子树的深度加上右子树的深度</span></span><br><span class="line">    <span class="keyword">return</span> d1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>); <span class="comment">// 任取一点作为根节点</span></span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-1075-数字转换"><a href="#AcWing-1075-数字转换" class="headerlink" title="AcWing 1075. 数字转换"></a><a href="https://www.acwing.com/problem/content/1077/">AcWing 1075. 数字转换</a></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">50010</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> g[N], e[M], ne[M], h[N], idx, st[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d1 = <span class="number">0</span>, d2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">dfs</span>(j) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(d &gt; d1) d2 = d1, d1 = d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d &gt; d2) d2 = d;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d1 + d2);</span><br><span class="line">    <span class="keyword">return</span> d1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="comment">// 枚举所有约数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j * i &lt;= n; j ++) <span class="comment">// 因为不包含自身约数 故j从2开始</span></span><br><span class="line">            g[i * j] += i;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) <span class="comment">// 1 的 约数之和（不包括1） 等于 0 但是要求正整数 因此从2开始枚举</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; g[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(g[i], i);</span><br><span class="line">            st[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的中心"><a href="#树的中心" class="headerlink" title="树的中心"></a>树的中心</h2><h3 id="AcWing-1073-树的中心"><a href="#AcWing-1073-树的中心" class="headerlink" title="AcWing 1073. 树的中心"></a><a href="https://www.acwing.com/problem/content/description/1075/">AcWing 1073. 树的中心</a></h3><p><a href="https://www.acwing.com/solution/content/6825/">题解</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">10010</span>, M = <span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], idx, w[M]; <span class="comment">// w 的范围和e ne 一样</span></span><br><span class="line"><span class="type">int</span> is_left[N], d1[N], d2[N], p[N], up[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> <span class="comment">// 获取u的深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d1[u] = d2[u] = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">dfs_1</span>(j, u) + w[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(d &gt; d1[u]) d2[u] = d1[u], d1[u] = d, p[u] = j;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d &gt; d2[u]) d2[u] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(d1[u] == <span class="number">-0x3f3f3f3f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        d1[u] = d2[u] = <span class="number">0</span>;</span><br><span class="line">        is_left[u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d1[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 注意 这里是从上往下搜索 因此up[u]的数值是知道的 需要和u的两大深度+w[i] 去比较</span></span><br><span class="line">        <span class="keyword">if</span>(j == p[u]) up[j] = <span class="built_in">max</span>(up[u], d2[u]) + w[i]; <span class="comment">// u的最大深度是否经过j 若是 则选择第二深度 </span></span><br><span class="line">        <span class="keyword">else</span> up[j] = <span class="built_in">max</span>(up[u], d1[u]) + w[i];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs_2</span>(j, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs_1</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs_2</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = d1[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">if</span>(is_left[i]) res = <span class="built_in">min</span>(res, up[i]);</span><br><span class="line">        <span class="keyword">else</span> res = <span class="built_in">min</span>(res, <span class="built_in">max</span>(up[i], d1[i]));</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-1074-二叉苹果树"><a href="#AcWing-1074-二叉苹果树" class="headerlink" title="AcWing 1074. 二叉苹果树"></a><a href="">AcWing 1074. 二叉苹果树</a></h2><p>有依赖背包问题简化版<br>状态表示 <code>f[i][j]</code><br>    集合 以i为根的子树中选择j条边的所有选法的集合<br>    属性 <code>Max</code><br>状态计算 以体积划分集合<br><code>f[u][j] = max(f[u][j], f[u][j - k - 1] + f[son][k] + w[i]);</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>, M = <span class="number">2</span> * N;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// f[i][j] 以i为根节点的子树中选 体积不超过j 的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], w[M], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 有依赖背包枚举顺序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])  <span class="comment">// 枚举物品组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> son = e[i];</span><br><span class="line">        <span class="keyword">if</span>(son == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(son, u);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j --) <span class="comment">// 枚举体积 从大到小！</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k ++) <span class="comment">// 枚举物品 注意-1 是因为你选了下面的上面的一定要选到 故还要+w[i]</span></span><br><span class="line">                f[u][j] = <span class="built_in">max</span>(f[u][j], f[u][j - k - <span class="number">1</span>] + f[son][k] + w[i]); <span class="comment">// 本题因为加的是边权 因此需要在for循环里面加 而有依赖背包那道题是点权 因此需要在外面对 f[u][j] 进行处理！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="AcWing-323-战略游戏"><a href="#AcWing-323-战略游戏" class="headerlink" title="AcWing 323. 战略游戏"></a><a href="https://www.acwing.com/problem/content/325/">AcWing 323. 战略游戏</a></h2><p>区别<br>    没有上司的舞会：每一条边至多选一个点 求最大权值<br>    战略游戏      ：每一条边至少选一个点 求最小权值  </p><p>状态表示 <code>f[i][0] f[i][1]</code></p><ol><li>集合 所有在以i为根的子树中选 且点i的状态是j(0, 1)的所有选法的集合</li><li>属性 <code>Min</code><br>状态计算 </li><li>f[i][0] +&#x3D; f[k][1]</li><li>f[i][1] +&#x3D; f[k][0]<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1510</span>;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>], st[N], n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[u][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        </span><br><span class="line">        f[u][<span class="number">1</span>] += <span class="built_in">min</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">        f[u][<span class="number">0</span>] += f[j][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> id, cnt;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d:(%d)&quot;</span>, &amp;id, &amp;cnt);</span><br><span class="line">            <span class="keyword">while</span>(cnt --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> v; cin &gt;&gt; v;</span><br><span class="line">                <span class="built_in">add</span>(id, v);</span><br><span class="line">                st[v] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(st[root]) root++;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(f[root][<span class="number">1</span>], f[root][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="AcWing-1077-皇宫看守"><a href="#AcWing-1077-皇宫看守" class="headerlink" title="AcWing 1077. 皇宫看守"></a><a href="https://www.acwing.com/problem/content/1079/">AcWing 1077. 皇宫看守</a></h2><p>f[i][0] 点i被父节点看到的最小花费 本身没有放警卫 因此子节点需要1. 放警卫 2. 被子节点的子节点看到  </p><p>f[i][1] 点i被子节点看到的最小花费 本身没有放警卫 因此子节点放警卫 </p><p>f[i][2] 点i放警卫的最小花费 因此子节点被父节点看到   </p><p>f[i][0] &#x3D; min f[j][1] f[j][2]<br>f[i][2] &#x3D; min f[j][0] f[j][1] f[j][2]<br>f[i][1] &#x3D; min(f[k][2] + min(f[j][1] f[j][2]))</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1510</span>;</span><br><span class="line"><span class="type">int</span> st[N], f[N][<span class="number">3</span>], w[N], n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">2</span>] = w[u];</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">min</span>(f[j][<span class="number">1</span>], f[j][<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">// f[u][1] = min(f[u][1], f[j][2] + sum - min(f[j][1], f[j][2]));</span></span><br><span class="line">        f[u][<span class="number">2</span>] += <span class="built_in">min</span>(<span class="built_in">min</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]), f[j][<span class="number">2</span>]);</span><br><span class="line">        sum += <span class="built_in">min</span>(f[e[i]][<span class="number">1</span>], f[e[i]][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    f[u][<span class="number">1</span>] = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        f[u][<span class="number">1</span>] = <span class="built_in">min</span>(f[u][<span class="number">1</span>], f[j][<span class="number">2</span>] + sum - <span class="built_in">min</span>(f[j][<span class="number">1</span>], f[j][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> id, cost, cnt;</span><br><span class="line">        cin &gt;&gt; id &gt;&gt; cost &gt;&gt; cnt;</span><br><span class="line">        w[id] = cost;</span><br><span class="line">        <span class="keyword">while</span>(cnt --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v; cin &gt;&gt; v;</span><br><span class="line">            <span class="built_in">add</span>(id, v);</span><br><span class="line">            st[v] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(st[root]) root ++;</span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(f[root][<span class="number">1</span>], f[root][<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长上升子序列模型</title>
      <link href="/post/d8a7c016.html"/>
      <url>/post/d8a7c016.html</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-895-最长上升子序列-LIS"><a href="#AcWing-895-最长上升子序列-LIS" class="headerlink" title="AcWing 895. 最长上升子序列 LIS"></a><a href="https://www.acwing.com/problem/content/897/">AcWing 895. 最长上升子序列 LIS</a></h1><h2 id="朴素版-O-n-2"><a href="#朴素版-O-n-2" class="headerlink" title="朴素版 $O(n^2)$"></a>朴素版 $O(n^2)$</h2><pre><code>集合表示：所有以a[i]结尾的上升子序列定义f[i]表示以第i个数结尾的上升序列的长度集合划分：&#39;以最后一个不同的点&#39; 即倒数第二个数划分为若干个集合（倒数第二个数也可能不存在）只有第i个数字大于某段上升序列末尾的数才可以选 if a[i] &gt; a[j] : f[i] = f[j] + 1 </code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N], a[N];</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;   </span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-896-最长上升子序列-II"><a href="#AcWing-896-最长上升子序列-II" class="headerlink" title="AcWing 896. 最长上升子序列 II"></a><a href="https://www.acwing.com/problem/content/898/">AcWing 896. 最长上升子序列 II</a></h2><pre><code>存储所有不同长度上升子序列结尾的值 随上升子序列长度增加，结尾的数越大 严格单调递增对于a[i] 接到最后一个小于a[i]的数后面 (二分!)</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x; <span class="comment">// 二分找到最后一个小于 x 的数</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &lt; x) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">max</span>(len, r + <span class="number">1</span>); <span class="comment">// 找到后 该序列加上x这个数字 故r + 1 </span></span><br><span class="line">        q[r + <span class="number">1</span>] = x; <span class="comment">// 而此时长度为r+1的序列末尾的数字就变成了x 因为本来末尾的数字大于x 而我们需要的是最小的</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; len;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-1017-怪盗基德的滑翔翼"><a href="#AcWing-1017-怪盗基德的滑翔翼" class="headerlink" title="AcWing 1017. 怪盗基德的滑翔翼"></a><a href="https://www.acwing.com/problem/content/1019/">AcWing 1017. 怪盗基德的滑翔翼</a></h1><pre><code>任意方向，因此最长上升子序列和最长下降子序列求 max</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> a[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i] &lt; a[j])</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                    f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-1014-登山"><a href="#AcWing-1014-登山" class="headerlink" title="AcWing 1014. 登山"></a><a href="https://www.acwing.com/problem/content/1016/">AcWing 1014. 登山</a></h1><pre><code>1. 按照编号递增的顺序来浏览2. 相邻两个景点不能相同3. 一旦开始下降，就不能上升目标：求最多能浏览多少景点求形状为∧的长度最大值从头和尾分别求一次LIS即可</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N], f1[N], f2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        f1[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                f1[i] = <span class="built_in">max</span>(f1[i], f1[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        f2[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt; i; j --)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                f2[i] = <span class="built_in">max</span>(f2[i], f2[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) res = <span class="built_in">max</span>(res, f1[i] + f2[i] - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-482-合唱队形"><a href="#AcWing-482-合唱队形" class="headerlink" title="AcWing 482. 合唱队形"></a><a href="https://www.acwing.com/problem/content/484/">AcWing 482. 合唱队形</a></h1><pre><code>与登山一致 ans = n - res</code></pre><h1 id="AcWing-1012-友好城市"><a href="#AcWing-1012-友好城市" class="headerlink" title="AcWing 1012. 友好城市"></a><a href="https://www.acwing.com/problem/content/1014/">AcWing 1012. 友好城市</a></h1><pre><code>条件1 每个城市只能建立一座桥条件2 任意桥不相交目标 最多可以建多少桥对北岸的城市编号进行排序 随后北岸从小到大考虑建桥，此时南岸对应所建的桥一定的严格递增。因此直接对南岸求最长上升子序列即可</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">5010</span>;</span><br><span class="line">PII tr[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">        cin &gt;&gt; tr[i].first &gt;&gt; tr[i].second;</span><br><span class="line">    <span class="built_in">sort</span>(tr + <span class="number">1</span>, tr + <span class="number">1</span> + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++)</span><br><span class="line">            <span class="keyword">if</span>(tr[i].second &gt; tr[j].second)</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-1016-最大上升子序列和"><a href="#AcWing-1016-最大上升子序列和" class="headerlink" title="AcWing 1016. 最大上升子序列和"></a><a href="https://www.acwing.com/problem/content/1018/">AcWing 1016. 最大上升子序列和</a></h1><pre><code>目标 求出最大上升子序列的和分析 最大上升子序列和不一定是最长上升子序列</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + a[i]);</span><br><span class="line">            </span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-1010-拦截导弹"><a href="#AcWing-1010-拦截导弹" class="headerlink" title="AcWing 1010. 拦截导弹"></a><a href="https://www.acwing.com/problem/content/description/1012/">AcWing 1010. 拦截导弹</a></h1><pre><code>贪心策略 从前往后扫描每一个数，对于每一个数    情况1 如果现有的的子序列的结尾都小于当前数 则创建新序列    情况2 将当前数放到大于等于它的最小的子序列后面本质是问最少用多少下降序列可以将所给的序列覆盖的问题。该问题的解决实际上和最基本模型的贪心做法相一致，这两个问题是对偶问题。一个序列最少用多少非上升子序列将它覆盖掉，是等于最长上升子序列的长度，Dilworth定理系统描述了这种问题。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N], g[N], f[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a[n]) n ++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt;= a[j]) <span class="comment">// 非严格递减</span></span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">        res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(g[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        g[r + <span class="number">1</span>] = a[i];</span><br><span class="line">        len = <span class="built_in">max</span>(len, r + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AcWing-187-导弹防御系统"><a href="#AcWing-187-导弹防御系统" class="headerlink" title="AcWing 187. 导弹防御系统"></a><a href="https://www.acwing.com/problem/content/189/">AcWing 187. 导弹防御系统</a></h1><pre><code>对于每个防御系统只能是单调下降、单调上升贪心策略：    对于每一个数都有4种方案    1. 单独作为上升序列    2. 加到上升序列末尾    3. 单独作为下降序列    4. 加到下降序列末尾只能使用暴搜 + 剪枝来实现</code></pre><h2 id="记录全局最优解"><a href="#记录全局最优解" class="headerlink" title="记录全局最优解"></a>记录全局最优解</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> a[N], up[N], down[N]; <span class="comment">// up  存储当前所有上升子序列的末尾元素</span></span><br><span class="line">                          <span class="comment">// down存储当前所有下降子系列的末尾元素 </span></span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> su, <span class="type">int</span> sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(su + sd &gt;= res) <span class="keyword">return</span> ; <span class="comment">// 剪枝</span></span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        res = su + sd;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况1 作为上升序列</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; su &amp;&amp; a[u] &lt; up[k]) k ++; <span class="comment">// 这里可以使用二分优化 但考虑到数据范围较小 因此没必要</span></span><br><span class="line">    <span class="type">int</span> t = up[k];</span><br><span class="line">    up[k] = a[u];</span><br><span class="line">    <span class="keyword">if</span>(k &gt;= su) <span class="built_in">dfs</span>(u + <span class="number">1</span>, su + <span class="number">1</span>, sd);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, su, sd);</span><br><span class="line">    up[k] = t; <span class="comment">// 回溯恢复现场</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况2 作为下降序列</span></span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; sd &amp;&amp; a[u] &gt; down[k]) k ++;</span><br><span class="line">    t = down[k];</span><br><span class="line">    down[k] = a[u];</span><br><span class="line">    <span class="keyword">if</span>(k &gt;= sd) <span class="built_in">dfs</span>(u + <span class="number">1</span>, su, sd + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">dfs</span>(u + <span class="number">1</span>, su, sd);</span><br><span class="line">    down[k] = t; <span class="comment">// 回溯恢复现场</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];</span><br><span class="line">        </span><br><span class="line">        res = n;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h2><pre><code>待补充~~~</code></pre><h1 id="AcWing-272-最长公共上升子序列"><a href="#AcWing-272-最长公共上升子序列" class="headerlink" title="AcWing 272. 最长公共上升子序列"></a><a href="https://www.acwing.com/problem/content/274/">AcWing 272. 最长公共上升子序列</a></h1><pre><code>状态表示：f[i][j]    集合 所有由第一个序列的前i个字母，和第二个序列的前j的字母构成，且以b[j]结尾的的公共上升子序列    属性 Max状态计算    集合划分        所有包含  a[i]的公共上升子序列        所有不包含a[i]的公共上升子序列 f[i - 1][j]</code></pre><h3>算法</h3><h5>(DP,线性DP,前缀和)  $O(n^2)$</h5><p>这道题目是<a href="https://www.acwing.com/problem/content/897/">AcWing 895. 最长上升子序列</a>和<a href="https://www.acwing.com/problem/content/899/">AcWing 897. 最长公共子序列</a>的结合版，在状态表示和状态计算上都是融合了这两道题目的方法。</p><p>状态表示：</p><ul><li><code>f[i][j]</code>代表所有<code>a[1 ~ i]</code>和<code>b[1 ~ j]</code>中以<code>b[j]</code>结尾的公共上升子序列的集合；</li><li><code>f[i][j]</code>的值等于该集合的子序列中长度的最大值；</li></ul><p>状态计算（对应集合划分）：</p><p>首先依据公共子序列中是否包含<code>a[i]</code>，将<code>f[i][j]</code>所代表的集合划分成两个不重不漏的子集：</p><ul><li>不包含<code>a[i]</code>的子集，最大值是<code>f[i - 1][j]</code>；</li><li>包含<code>a[i]</code>的子集，将这个子集继续划分，依据是子序列的倒数第二个元素在<code>b[]</code>中是哪个数：<ul><li>子序列只包含<code>b[j]</code>一个数，长度是1；</li><li>子序列的倒数第二个数是<code>b[1]</code>的集合，最大长度是<code>f[i - 1][1] + 1</code>；</li><li>&hellip;</li><li>子序列的倒数第二个数是<code>b[j - 1]</code>的集合，最大长度是<code>f[i - 1][j - 1] + 1</code>；</li></ul></li></ul><p>如果直接按上述思路实现，需要三重循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> maxv = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; j; k ++ )</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; b[k])</span><br><span class="line">                    maxv = <span class="built_in">max</span>(maxv, f[i - <span class="number">1</span>][k] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], maxv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们发现每次循环求得的<code>maxv</code>是满足<code>a[i] &gt; b[k]</code>的<code>f[i - 1][k] + 1</code>的前缀最大值。<br />因此可以直接将<code>maxv</code>提到第一层循环外面，减少重复计算，此时只剩下两重循环。</p><p>最终答案枚举子序列结尾取最大值即可。</p><h4>时间复杂度</h4><p>代码中一共两重循环，因此时间复杂度是 $O(n^2)$。</p><h4>C++ 代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> maxv = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], maxv);</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; b[j]) maxv = <span class="built_in">max</span>(maxv, f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 最长上升子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/post/b2626942.html"/>
      <url>/post/b2626942.html</url>
      
        <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>所有从<code>i-1</code>层转移过来的都要从大到小循环 所有从<code>i</code>层转移过来的都要从小到大循环</p><p>总结：所有背包问题优化成一维之后 只有<code>完全背包问题和多重背包单调队列优化</code>体积是从小到大循环的</p><pre><code>for 物品    for 体积        for 决策不超过:    f = 0 保证j - v &gt;= 0恰好:    f[0][0][0] = 0, f[0][j][k] = (+-)0x3f3f3f3f\0; 保证j - v &gt;= 0 // f的取值具体情况具体分析至少    f[0][0][0] = 0, f[0][j][k] = (+-)0x3f3f3f3f; max(0, j - v) // 负数的时候也要考虑 万一价值更加合适呢</code></pre><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="二维模板"><a href="#二维模板" class="headerlink" title="二维模板"></a>二维模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, w;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j]; <span class="comment">// 不选</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= x) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - x] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维模板-j从m到v"><a href="#一维模板-j从m到v" class="headerlink" title="一维模板 j从m到v"></a>一维模板 <code>j从m到v</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="type">int</span> s, w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; w;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= s; j--)</span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j - s] + w);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-734-能量石"><a href="#AcWing-734-能量石" class="headerlink" title="AcWing 734. 能量石"></a><a href="https://www.acwing.com/problem/content/description/736/">AcWing 734. 能量石</a></h3><ol><li>先贪心！<br>假定吃的时候<code>i</code>和<code>i + 1</code>这两块石头的能量都大于0 则获得的能量为<code>Ei + Ej - Si * Lj</code> (这里的E表示的是吃第一块的一瞬间两块石头剩余的能量)<br>换过来呢就是<code>Ej + Ei - Sj * Li</code> 什么情况下第一种更好呢？<code>Si * Lj &lt; Sj * Li</code><br>即<code>Si / Li &lt; Sj / Lj</code> 按照这种情况排序  </li><li>01背包！<ol><li>状态表示<code>f[i][j]</code><ol><li>集合 所有从前i个物品中选，且总体积恰好是j的方案 &#x2F;&#x2F; 体积是时间 之所以是恰好 是因为时间不是越大越好 能量石的能量会随时间流逝</li><li>属性 Max</li></ol></li><li>状态计算 <code>f[i][j] = max(f[i - 1][j], f[i - 1][j - s] + e - (j - s) * L)</code></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s, e, l;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp; node) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> s * node.l &lt; node.s * l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> C = <span class="number">1</span>; C &lt;= T; C ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s, e, l;</span><br><span class="line">            cin &gt;&gt; s &gt;&gt; e &gt;&gt; l; <span class="comment">// time get lost</span></span><br><span class="line">            m += s;</span><br><span class="line">            tr[i] = &#123;s, e, l&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(tr + <span class="number">1</span>, tr + n + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = tr[i].s, e = tr[i].e, l = tr[i].l;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= s; j --)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - s] + e - (j - s) * l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) res = <span class="built_in">max</span>(res, f[j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>, C, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="二维优化模板"><a href="#二维优化模板" class="headerlink" title="二维优化模板"></a>二维优化模板</h3><pre><code>求所有前缀的最大值</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v, w;</span><br><span class="line">cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)</span><br><span class="line">&#123;</span><br><span class="line">    f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">if</span>(j &gt;= v)</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j - v] + w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[n][m];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维优化模板-j从v到m"><a href="#一维优化模板-j从v到m" class="headerlink" title="一维优化模板 j从v到m"></a>一维优化模板 <code>j从v到m</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v, w;</span><br><span class="line">cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = v; j &lt;= m; j ++)</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[m];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-532-货币系统"><a href="#AcWing-532-货币系统" class="headerlink" title="AcWing 532. 货币系统"></a><a href="https://www.acwing.com/problem/content/534/">AcWing 532. 货币系统</a></h3><p>性质1 <code>a1 a2 .. an</code> 一定可以表示出来<br>性质2 在最优解中 <code>b1 b2 .. bm</code> 一定都是从<code>a1 a2 .. an</code> 中选择<br>性质3 <code>b1 b2 .. bm</code> 一定不能被其他 <code>bi</code>表示</p><pre><code>以此从小到大枚举每一个数 若该数能被之前的凑出，则`continue`简单来说就是完全背包计算能否恰好凑出体积m</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">25010</span>, M = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N], a[M], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[a[i]]) <span class="keyword">continue</span>;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = a[i]; j &lt; N; j++)</span><br><span class="line">                f[j] |= f[j - a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="多重背包Ⅰ"><a href="#多重背包Ⅰ" class="headerlink" title="多重背包Ⅰ"></a>多重背包Ⅰ</h3><h4 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s &amp;&amp; j &gt;= k * v; k ++) <span class="comment">// k == 0 的时候就是不选的情况 因此不需要特殊处理f[i][j] = f[i - 1][j]</span></span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v] + k * w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维-j从m到0"><a href="#一维-j从m到0" class="headerlink" title="一维 j从m到0"></a>一维 <code>j从m到0</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v; j --)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s &amp;&amp; j &gt;= k * v; k ++)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - k * v] + k * w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包Ⅱ-二进制"><a href="#多重背包Ⅱ-二进制" class="headerlink" title="多重背包Ⅱ 二进制"></a>多重背包Ⅱ <code>二进制</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> w[N], v[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; <span class="comment">// v w s</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            c -= k;</span><br><span class="line">            v[cnt] = k * a;</span><br><span class="line">            w[cnt] = k * b;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = c * a;</span><br><span class="line">            w[cnt] = c * b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包Ⅲ-单调队列-滑动窗口求最值"><a href="#多重背包Ⅲ-单调队列-滑动窗口求最值" class="headerlink" title="多重背包Ⅲ 单调队列 -&gt; 滑动窗口求最值"></a>多重背包Ⅲ <code>单调队列 -&gt; 滑动窗口求最值</code></h3><p><code>求滑动窗口内的最大值</code> <a href="https://www.acwing.com/solution/content/6500/">题解</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N], g[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="built_in">memcpy</span>(g, f, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt;= m; k += v)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; q[hh] &lt; k - s * v) hh ++ ;</span><br><span class="line">                <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; g[q[tt]] - (q[tt] - j) / v * w &lt;= g[k] - (k - j) / v * w) tt -- ;</span><br><span class="line">                q[ ++ tt] = k;</span><br><span class="line">                f[k] = g[q[hh]] + (k - q[hh]) / v * w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> s[N], w[N][N], v[N][N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j ++)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j]; <span class="comment">// 注意这个要放在循环外 若放在内层循环会改变最大值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v[i][k])</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i][k]] + w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m];  </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> s[N], w[N][N], v[N][N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j ++)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span> ; j --)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s[i]; k ++)</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v[i][k])</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">                    </span><br><span class="line">    cout &lt;&lt; f[m];  </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-487-金明的预算方案"><a href="#AcWing-487-金明的预算方案" class="headerlink" title="AcWing 487. 金明的预算方案"></a><a href="https://www.acwing.com/problem/content/489/">AcWing 487. 金明的预算方案</a></h3><p>有依赖背包+分组背包</p><p>可以将每个主件及其附件看作一个物品组，记主件为 p，两个附件为a,b，则最多一共有4种组合：</p><ol><li>p</li><li>p,a</li><li>p,b</li><li>p,a,b</li></ol><p>这四种组合是互斥的，最多只能从中选一种，因此可以将每种组合看作一个物品，那么问题就变成了分组背包问题。可以参考<a href="https://www.acwing.com/problem/content/9/">AcWing 9. 分组背包问题</a>。</p><p>在枚举四种组合时可以使用二进制的思想，可以简化代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">70</span>, M = <span class="number">32010</span>;</span><br><span class="line">PII master[N];</span><br><span class="line">vector&lt;PII&gt; servent[N];</span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//价格，p表示该物品的重要度（1~5），q表示该物品是主件还是附件。</span></span><br><span class="line">        <span class="type">int</span> v, p, q;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; p &gt;&gt; q;</span><br><span class="line">        <span class="keyword">if</span>(!q) master[i] = &#123;v, v * p&#125;;</span><br><span class="line">        <span class="keyword">else</span> servent[q].<span class="built_in">push_back</span>(&#123;v, v * p&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">        <span class="keyword">if</span>(master[i].first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; servent[i].<span class="built_in">size</span>(); k ++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> v = master[i].first, w = master[i].second;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; servent[i].<span class="built_in">size</span>(); u ++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(k &gt;&gt; u &amp; <span class="number">1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            v += servent[i][u].first;</span><br><span class="line">                            w += servent[i][u].second;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j &gt;= v) f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>状态表示 <code>f[i][j][k]</code><ol><li>集合 所有只从前i个物品中选，并且<code>费用1</code>不超过j,<code>费用2</code>不超过k的选法</li><li>属性 <code>Max</code></li></ol></li><li>状态计算 <ol><li>所有不包含物品的选法 <code>f[i - 1][j][k]</code></li><li>所有  包含物品的选法 <code>f[i - 1][j - v1][k - v2] + w</code></li></ol></li></ol><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, V, M;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; V &gt;&gt; M; <span class="comment">// 物品数 体积 重量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, m, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; m &gt;&gt; w; <span class="comment">// 、、 价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = V; j &gt;= v; j --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = M; k &gt;= m; k --)</span><br><span class="line">            &#123;</span><br><span class="line">                f[j][k] = <span class="built_in">max</span>(f[j][k], f[j - v][k - m] + w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[V][M];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-1022-宠物小精灵之收服"><a href="#AcWing-1022-宠物小精灵之收服" class="headerlink" title="AcWing 1022. 宠物小精灵之收服"></a><a href="https://www.acwing.com/problem/content/1024/">AcWing 1022. 宠物小精灵之收服</a></h3><pre><code>二维费用背包问题花费1 精灵球的数量花费2 皮卡丘的体力值价值  小精灵的数量f[i][j][k]所有只从前i个物品中选 花费1不超过j 花费2不超过k的选法的最大价值f[i][j][k] = max(f[i - 1][j][j], f[i - 1][j - v1[i]][k - v2[i]] + (w[i] == 1))最多收服的小精灵数量 f[K][N][M]最少耗费体力 f[K][N][m] == f[K][N][M]</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//f[i][j][k] </span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> M = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> V1, V2, n; <span class="comment">// 小智的精灵球数量、皮卡丘初始的体力值</span></span><br><span class="line">    cin &gt;&gt; V1 &gt;&gt; V2 &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v1, v2, w = <span class="number">1</span>;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = V1; j &gt;= v1; j --)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = V2 - <span class="number">1</span>; k &gt;= v2; k --) <span class="comment">// 体力值至少为1</span></span><br><span class="line">                f[j][k] = <span class="built_in">max</span>(f[j][k], f[j - v1][k - v2] + w);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[V1][V2 - <span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; ; i ++)</span><br><span class="line">        <span class="keyword">if</span>(f[V1][i] == f[V1][V2 - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; V2 - i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-1020-潜水员"><a href="#AcWing-1020-潜水员" class="headerlink" title="AcWing 1020. 潜水员"></a><a href="https://www.acwing.com/problem/content/1022/">AcWing 1020. 潜水员</a></h3><pre><code>所有只从前面i个物品中选，并且总体积至少是j，总重量至少是k的选法Min</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">30</span>][<span class="number">90</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N, M, K; <span class="comment">//氧 氮 气缸的个数</span></span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;  <span class="comment">//气缸里的氧和氮的容量及气缸重量。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">21</span>; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">79</span>; k &gt;= <span class="number">0</span>; k --)</span><br><span class="line">                f[j][k] = <span class="built_in">min</span>(f[j][k], f[<span class="built_in">max</span>(<span class="number">0</span>, j - a)][<span class="built_in">max</span>(<span class="number">0</span>, k - b)] + c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[N][M];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案数"><a href="#方案数" class="headerlink" title="方案数"></a>方案数</h2><h3 id="经验-1"><a href="#经验-1" class="headerlink" title="经验"></a>经验</h3><pre><code>typedef lonh long LL;</code></pre><h3 id="AcWing-278-数字组合"><a href="#AcWing-278-数字组合" class="headerlink" title="AcWing 278. 数字组合"></a><a href="https://www.acwing.com/problem/content/280/">AcWing 278. 数字组合</a></h3><pre><code>01背包求方案数(装满背包的方案书)恰好 但是非法方案f就是等于0f[0] = 1; f[j] += f[j - v];</code></pre><h3 id="AcWing-1021-货币系统"><a href="#AcWing-1021-货币系统" class="headerlink" title="AcWing 1021. 货币系统"></a><a href="https://www.acwing.com/problem/content/1023/">AcWing 1021. 货币系统</a></h3><pre><code>完全背包求方案数(装满背包的方案书)恰好 注意初始化 f[0] = 1 // 从前i个物品中选 体积恰好是0 因此只有1中方案就是啥都不选                 else f = 0</code></pre><h3 id="AcWing-11-背包问题求方案数"><a href="#AcWing-11-背包问题求方案数" class="headerlink" title="AcWing 11. 背包问题求方案数"></a><a href="https://www.acwing.com/problem/content/11/">AcWing 11. 背包问题求方案数</a></h3><pre><code>本题是求最优解(价值最大)的方案数等价于求最短路径的条数</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> f[N], g[N]; <span class="comment">// 恰好 f价值 g方案</span></span><br><span class="line"><span class="comment">//f[i]表示体积恰好为i的总价值 g[i]表示体积恰好为j价值最大的方案数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> f); <span class="comment">//恰好的初始化方式</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 啥也不装 价值为0 </span></span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 体积为0 只有啥都不选这一种方案</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v; j --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> maxv = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[j] == maxv) cnt = (cnt + g[j]) % mod; <span class="comment">// 大概就类似求最短路径的条数 看看是否能从f[i-1][j]转移过来 若可以 则加上该方案 下面f[i-1][j-v]同理</span></span><br><span class="line">            <span class="keyword">if</span>(f[j - v] + w == maxv) cnt = (cnt + g[j - v]) % mod;</span><br><span class="line">            g[j] = cnt; f[j] = maxv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到最大价值 因为f表示的是恰好 f[m不一定是最大价值]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) res = <span class="built_in">max</span>(res, f[j]); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 把所有最大价值的 方案都加起来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)</span><br><span class="line">        <span class="keyword">if</span>(f[j] == res)</span><br><span class="line">            cnt = (cnt + g[j]) % mod;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题求具体方案"><a href="#背包问题求具体方案" class="headerlink" title="背包问题求具体方案"></a>背包问题求具体方案</h2><h3 id="konw"><a href="#konw" class="headerlink" title="konw"></a>konw</h3><p>所谓求具体方案其实就是判断出每个物品是否被选，对应的是: <code>最短路问题</code>求最短路径 </p><p>以01背包为例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])</span><br><span class="line">f[n][m]</span><br></pre></td></tr></table></figure><p>本质是求从哪条路劲走到<code>f[n][m]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为了保证字典序最小，采用贪心策略：从小到大对于每一个物品由3种情况</span><br><span class="line">    1. 只能选 选！</span><br><span class="line">    2. 不能选 不选！</span><br><span class="line">    3. 可选可不选 选！</span><br><span class="line">但是我们推出方案是从后往前得到的，和贪心策略相反。怎么办呢？ </span><br><span class="line">只需求解01背包的时候从后往前推即可</span><br></pre></td></tr></table></figure><h3 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; v[i] &gt;&gt; w[i]; <span class="comment">// 注意输入问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i])</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i + <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// f[1][m]为最大价值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从后往前推</span></span><br><span class="line">    <span class="type">int</span> j = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= v[i] &amp;&amp; f[i][j] == f[i + <span class="number">1</span>][j - v[i]] + w[i]) <span class="comment">// 可选 则选</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            j -= v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing-1013-机器分配"><a href="#AcWing-1013-机器分配" class="headerlink" title="AcWing 1013. 机器分配"></a><a href="https://www.acwing.com/problem/content/1015/">AcWing 1013. 机器分配</a></h3><p>分组背包问题</p><pre><code>分析：把每个公司当成一个物品组例如公司1有3个物品(v,w)-&#123;(1, 30)(2, 40)(3, 50)&#125;M表示体积 求最大价值综上所述：分组背包模板</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][N], v[N][N], w[N][N];</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">            v[i][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v[i][k])</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i][k]] + w[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> j = m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) mp[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i --) <span class="comment">// 注意从后往前推答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= m; k ++)</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i][k] &amp;&amp; f[i][j] == f[i - <span class="number">1</span>][j - v[i][k]] + w[i][k])</span><br><span class="line">            &#123;</span><br><span class="line">                mp[i] = k;</span><br><span class="line">                j -= v[i][k];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [u, v] : mp) cout &lt;&lt; u &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; endl; </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><h3 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h3><h4 id="AcWing-7-混合背包问题"><a href="#AcWing-7-混合背包问题" class="headerlink" title="AcWing 7. 混合背包问题"></a><a href="https://www.acwing.com/problem/content/7/">AcWing 7. 混合背包问题</a></h4><p>分类讨论即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(!s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = v; j &lt;= m; j ++) f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="number">-1</span>) s = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= s; k *= <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= k * v; j --)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - k * v] + k * w);</span><br><span class="line">                s -= k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= s * v; j --)</span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j], f[j - s * v] + s * w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有依赖背包"><a href="#有依赖背包" class="headerlink" title="有依赖背包"></a>有依赖背包</h2><h3 id="前置知识树形dp"><a href="#前置知识树形dp" class="headerlink" title="前置知识树形dp"></a>前置知识<code>树形dp</code></h3><h4 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a><a href="https://www.acwing.com/problem/content/description/287/">没有上司的舞会</a></h4><p><code>f[i][0]</code>表示以<code>i</code>为根的子树，不选第<code>i</code>个点的情况下，选出来的最大价值是多少<br><code>f[i][1]</code>表示以<code>i</code>为根的子树，  选第<code>i</code>个点的情况下，选出来的最大价值是多少<br>状态转移<br>        <code>f[i][0] += max(f[j][0], f[j][1])</code> <code>for(j : i的所有子树)</code><br>        <code>f[i][1] += f[j][0]</code> <code>for(j : i的所有子树)</code> &#x2F;&#x2F; i选了 子树全都不能选啦<br>最终答案 <code>ans == max(f[i][0], f[i][1])</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">6010</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], idx;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>], w[N], st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// f[u][0] = 0; 最坏的情况下可以啥都不选 因此直接设置为0即可</span></span><br><span class="line">    f[u][<span class="number">1</span>] = w[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">1</span>], f[j][<span class="number">0</span>]);</span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) cin &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">        st[a] = <span class="number">1</span>; <span class="comment">// 是否存在父节点 标记一下 一遍搜寻根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(st[root]) root ++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root); <span class="comment">// 从根节点开始树形DP</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[root][<span class="number">1</span>], f[root][<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-10-有依赖的背包问题"><a href="#AcWing-10-有依赖的背包问题" class="headerlink" title="AcWing 10. 有依赖的背包问题"></a><a href="https://www.acwing.com/problem/content/10/">AcWing 10. 有依赖的背包问题</a></h4><p>目标 <code>f[u][j]</code><br>    1. 集合 所有从以u为根的子树中选，且总体积不超过j的方案 - 一维dp的简单拓展<br>    2. 属性 Max<br>集合划分 划分为从分别子树中选择 每一颗子树内部按体积划分(0 ~ m)</p><h5 id="核心观点：f-u-j-的第一维代表的是节点，对应树形DP问题；第二维是体积，代表一维分组背包问题"><a href="#核心观点：f-u-j-的第一维代表的是节点，对应树形DP问题；第二维是体积，代表一维分组背包问题" class="headerlink" title="核心观点：f[u][j]的第一维代表的是节点，对应树形DP问题；第二维是体积，代表一维分组背包问题"></a>核心观点：<code>f[u][j]</code>的第一维代表的是节点，对应树形DP问题；第二维是体积，代表一维分组背包问题</h5><p><code>f[u][j]</code>：在”以u为根节点的子树”中选，节点u必选，所选体积不超过j，的所有方案中，价值最大的方案的价值</p><p>计算<code>f[u][j]</code>时，先通过分组背包的方式计算在所有孩子节点中选的最大价值，最后再考虑节点u。设节点u有p个孩子节点，那么就相当于有p组物品。</p><p>物品组为1∼p，总共可用的体积为<code>m−v[u]</code>。现在我们眼中只有p组物品，先不考虑父亲节点，只考虑计算这p组物品的最大价值</p><p>根据分组背包的做法，首先枚举物品组，也就是节点u的某个孩子son，对应代码的<code>for (int i = h[u]; i != -1; i = ne[i])</code></p><p>其次枚举体积j，也就是考虑在1∼son的物品组中选，所选体积不超过jj的最大价值。<br>最后枚举在物品组son中选体积为kk的物品，k∈[0,j]，因为1∼son的物品组一共选了不超过j的体积</p><p>状态转移是<code>f[u][j] = max(f[u][j], f[u][j - k] + f[son][k])</code>。</p><p><code>f[u][j-k]</code>: 由于体积j是从大到小枚举，所以这里<code>f[u][j-k]</code>表示在1∼son−1的物品组中选，体积不超过j−k的方案的最大价值，这里省略了表示”在1∼son−1的物品组中选”的维度，相当于一维的分组背包。而<code>f[u][j]</code>的第一维代表的不是背包问题，而是树形DP，第二维代表的才是分组背包。所以这道题是树形DP和背包的综合。</p><p><code>f[son][k]</code>: 由于状态转移之前已经递归调用了<code>dfs(son)</code>，所以以son为根的子树已经计算好了。<code>f[son][k]</code>表示在以son为根的子树中选，所选体积不超过k的最大价值<br>综上，<code>f[u][j−k]+f[son][k]</code>的前半部分更趋向于分组背包，后半部分趋向于树形DP</p><p>计算完<code>f[u][*]</code>之后，<code>f[u][*]</code>代表的其实是在节点u的所有子树1∼p中选的最大价值，没有计算u的价值，所以需要加上最后的两个for循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">110</span>, M = N * N;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> e[N], ne[N], idx, h[N];</span><br><span class="line"><span class="type">int</span> f[N][M];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i]) <span class="comment">// 循环物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> son = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(son);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m - v[u]; j &gt;= <span class="number">0</span>; j --) <span class="comment">// 多重背包 从大到小 循环体积</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= j; k ++) <span class="comment">// 循环决策 将每棵树按照分配体积分成0~m</span></span><br><span class="line">                f[u][j] = <span class="built_in">max</span>(f[u][j], f[u][j - k] + f[son][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将u加进去</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[u]; j --) f[u][j] = f[u][j - v[u]] + w[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;  v[u]; j ++) f[u][j] = <span class="number">0</span>; <span class="comment">// 当体积小于v[u]的时候 一定放不进去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="type">int</span> root;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">-1</span>) root = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[root][m];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数划分模型</title>
      <link href="/post/75e76536.html"/>
      <url>/post/75e76536.html</url>
      
        <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><pre><code>将n划分成多个数相加 有几种划分方案？</code></pre><h1 id="解法1-完全背包"><a href="#解法1-完全背包" class="headerlink" title="解法1 完全背包"></a>解法1 完全背包</h1><pre><code>f[i][j]表示从i个物品里面选恰好凑出体积为j的方案数</code></pre><h2 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><pre><code>f[i][j] = f[i - 1][j] + f[i][j - i]写成一维: f[j] = f[j] + f[j - i]</code></pre><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法2-k部分拆数"><a href="#解法2-k部分拆数" class="headerlink" title="解法2 (k部分拆数)"></a>解法2 (k部分拆数)</h1><pre><code>f[i][j]表示由j个数组成i的方案数</code></pre><h2 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h2><pre><code>1. 有1 f[i - 1][j - 1] // 去掉1个12. 无1 f[i - j][j]     // 所有数减掉1f[i][j] = f[i - 1][j - 1] + f[i - j][j]</code></pre><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j ++)</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % mod;</span><br><span class="line">            </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = (res + f[n][i]) % mod ;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 整数划分 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
